{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"source/img/avatar/2077_mobile.png","path":"img/avatar/2077_mobile.png","modified":0,"renderable":0},{"_id":"source/img/logo/mesh.png","path":"img/logo/mesh.png","modified":0,"renderable":0},{"_id":"source/img/signature/signature-removebg.png","path":"img/signature/signature-removebg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1712715865003},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1712715986268},{"_id":"themes/butterfly/README.md","hash":"4e01b47448d9f3a02afc04eef644e2321253f6f4","modified":1712715986268},{"_id":"themes/butterfly/README_CN.md","hash":"148da187d16033624ceccce8b8561835296f5a5a","modified":1712715986268},{"_id":"themes/butterfly/_config.yml","hash":"39fbabbbf1e89dd82a6ea21517c6c24b49e4dd98","modified":1712715986268},{"_id":"themes/butterfly/package.json","hash":"314b0271ba3f668d0d6081b499b2d24e90dab25e","modified":1712715986278},{"_id":"themes/butterfly/plugins.yml","hash":"d807fbb62163bb6fc5a83a24ebd69ac14cf45f67","modified":1712715986278},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1712715986268},{"_id":"themes/butterfly/languages/default.yml","hash":"90a6dc361de67532437d819a55ec64945ca5404b","modified":1712715986268},{"_id":"themes/butterfly/languages/en.yml","hash":"af5603b1a888f167dc80be6d53a19437b5cf6bef","modified":1712715986268},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"5004faee365139521f161babd66649a8107e4008","modified":1712715986268},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"03629d1d13a7be09d4933aa5dc0dcbe45e79140c","modified":1712715986268},{"_id":"themes/butterfly/layout/archive.pug","hash":"bb32c9c476372de747dfa563b83f77d7a917a77d","modified":1712715986268},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1712715986268},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1712715986278},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1712715986278},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1712715986278},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1712715986278},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"6e34b565ea013812d5e363b6de5fa1f9078d4e12","modified":1712715986268},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7b4831ae8f8f8c55dd1b856781210c517c63e6dd","modified":1712715986268},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1712715986268},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1712715986268},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"ecec62305aaa596bb1dfbb46c13d06fb5a9628cf","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"db275f7fbe4438b54cd813b695f4834e10aa234f","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1712715986278},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1712715986278},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1712715986278},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1712715986278},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1712715986278},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"2ac43fd4103ba3c6897da7c13015cb05f39fd695","modified":1712715986278},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"e196a99733d7f90899bceed5d12488e8234817d5","modified":1712715986278},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1712715986278},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"860f967ecf3c6a6ea785b560a7aae4d0757cd18a","modified":1712715986278},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a8eef3f37428436554f58a2b6bac7c255fbdf38d","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"93229d44b35b9da92e647b89d6d3087085974a29","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"418684993a3a3a2ac534257a2d9ecbcead6808c1","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"512c68a22ae4a58d6a6b24b368a0c00c2ccb4fcb","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"19773218877281ccffed921431e87148413a7c20","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"365db87ddfc582bf8c15cb440c48bed95106e4b1","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"1acefc59ead75ebd8cafee36efc7da4fa426d088","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"5c2a07df5874b5377540884e4da14dd21489378f","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"5cb273e95846874e3a58074074c501df23c5e912","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"830b1d592278b9f676df0cf9a91b1eeda2456aec","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"ffc62222f8d7b4d44c1c0726c8a08824a2201039","modified":1712715986278},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4526c75e5bf84609d67e92b6af3524bcb278e852","modified":1712715986278},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1712715986278},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"96f861151e3b889ef0ffe78821d489ad2625ee43","modified":1712715986278},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"7caf549810f971c34196fb9deac2d992545bdff9","modified":1712715986278},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"d5c7e61257b08a9648404f6f48ce4d471cd5fa55","modified":1712715986278},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"e2a8a09bfe47da26eab242a36f516e6c452c799a","modified":1712715986278},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1712715986278},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"821e973d41f7b3b64cde91e0e836ea49c43e3c06","modified":1712715986278},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1712715986278},{"_id":"themes/butterfly/source/css/var.styl","hash":"152b6bd4b6285165541a71f5a1c913f8ee6a602b","modified":1712715986278},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1712715986278},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1712715986278},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1712715986278},{"_id":"themes/butterfly/source/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1712715986278},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1712715986278},{"_id":"themes/butterfly/source/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"63fed4548367a3663cdbaffa1df48167b0a2397b","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"5208fe1e75d97a05fd9bdd6cc53c59d8b741b94b","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"f50e6a17073677933c5bc78481bf587a4a9e6da0","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"6f310ca7b392021632b987557607d5b6d18052bb","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"5574804fdea5edf7fd52aad2caf030614d5e7f2f","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"a096ff8eb6b2a22395be881f827ff2a686ba5596","modified":1712715986268},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"1d39670ee6225f85f5c53bf5c84f3fd6e19290e8","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"12e57491e94fa00d953bbda9db0b6d6169e2358c","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"bd5ad01277f8c6ddf8a3a29af1518e5fe6eed23f","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"a658a274c5f7896ee5122725bee45548693bdd66","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"66f7a8b0cebc05c575ec3cb70b08d6854029d87a","modified":1712715986278},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f19694a42dbe28eda4b39a1696e8fbcd277bc76c","modified":1712715986278},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"c8ff6ddd5bfe1190b7b8056b68ce41114fd79dcb","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"fad650f88778b33a6358e38cf50dfafc0974d28f","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"18d08be0cd9b1f8c049d4b922e80f8163a55c947","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"a2eb44fa5eaea1325319a2064439cf36d0f35a2f","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"134811b2d696f9ed2c0cd578f3886f1c60770c0a","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d6cf26ffb8a0343eda1cde65b6b73b0ddbe8fcfc","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"f845b9b4efdee750f70c023aab27432611f83059","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1712715986278},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"b7a6a585dbc38d177c9aba75df3a467415d0488a","modified":1712715986278},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"0db591a1f4ed5adcb8668a549bbee5c9d62682cf","modified":1712715986278},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"e549d24ad81a7d93326a509ff8dcfcc58c80729e","modified":1712715986278},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"4dcd468e4d11a0ac75406162678feffcd89fee00","modified":1712715986278},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1712715986278},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1712715986278},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1712715986278},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1712715986278},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1712715986278},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1712715986278},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"d4ebc41b5c855dd75f47de7345d62f85ce7cf073","modified":1712715986278},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"5cddbb5f4eae695a26685e415d821b523e0f17bf","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"909bb5079b26b6ee68177919f522566503654058","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1712715986278},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"2d02e52b360f6e6cae47c293ae57ed78e2554663","modified":1712715986278},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1712715986278},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1712715986278},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"961589da3c0a532c4709a4a4ea96bd579257f766","modified":1712715986278},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1712715986278},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1712715986278},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"f7299f9fef5bf94bb58c8cd3be8ee660ad2f9cd4","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"71af0b679e00290b0854384368b3c7e9b3e5f26a","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"c5f7081ca29db8cc80f808dfc29e36d5fa22fd7e","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"3a5ccfc69bd8ccb4b8f3ce3502023f7914f2a022","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"f77f0fdeac2bc8a72f71a58f9b75aa39f0a108c8","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"62f16a602e57e5f7f7c5249dd37b42d436dc032a","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"3bc4c1b91568561f0491bdac65b75aa0bfd01f27","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"2d7b0b09678adba09481e3152e0b32962677f650","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"46aec6466959baec1c3d71a5dbc510fbeb00c91d","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0d378ee8a671982a46213a4bfb223b4f3409aea9","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"a9709905593d960954e2dd572f09f48a6c2b1ef7","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"63cea2b5c8f7b59f5919379d61a2bb2ce8ed7623","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f15699abb8c7a255aabad0222ae53eee387c66a3","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"5c29b5887e2e6cd81e1f13b32da53d9c139b788b","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1995a654ba7ad62775a0a6e2922209cd1a85f2e3","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"46865e3f52096acb07d0212174b4e8751b123aea","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"7aa443b4881448979b810864e206e58c9ed787e3","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"6b67982bb7a3713b5bffd6a23ba2810425c504d0","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"17080aba1754478197ab089f7948ed900f116d2b","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"2609bc2656aaaa9b59e8d575e711776512a62192","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0f0b46d637a9a1b6ae35148923abecc80b866276","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"de2c4d02b520dd49a0a59fc0f33295e5bbb2c624","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"4104f96faa6040f111ebfb9a90eeb470857c3b86","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"1f9f51023e9e33081c2add2ca73643c0edc5e9d5","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"24804ab6da9727ed793655c1262fa3f1a9746f70","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"b928be14d1b47a9fadb1bcc5f5072a7328752d4b","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"3335024ba91f55ccf3858571b7898f46881c455c","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"3ba49cfe186e9ca05faf9f0d0113611ec47e9b38","modified":1712715986278},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1712715986278},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1712715986278},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1712715986278},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1712715986278},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1712715986278},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"25914321762e30aacc610bc4dfb9de3e1cb556a3","modified":1712715986278},{"_id":"public/2024/04/10/hello-world/index.html","hash":"ddad90935a2fbc33fb4828e8e5f9048a7c2f4dce","modified":1712721087896},{"_id":"public/archives/index.html","hash":"b57dcdd99c147d375ab5fd2f18d50fdb975dbf16","modified":1712845257055},{"_id":"public/archives/2024/index.html","hash":"542eec82582f1fc66c972e94c4ab4f7706eef359","modified":1712845257055},{"_id":"public/archives/2024/04/index.html","hash":"f4acc34d84318e4b8910a970a2cef257ad27bd46","modified":1712845257055},{"_id":"public/index.html","hash":"a9a49bbba398d39b85ddad47ff30eb5e9c23c65f","modified":1712845257055},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1712722700433},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1712722700433},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1712722700433},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1712722700433},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1712722700433},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1712722700433},{"_id":"public/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1712722700433},{"_id":"public/css/index.css","hash":"ab5c2258c045b9c9c3473697fed60077ad5258ec","modified":1712722700433},{"_id":"public/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1712722700433},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1712722700433},{"_id":"source/_data/link.yml","hash":"560dea5252fac932c2ebc871f98dae59a7ce91e5","modified":1712843916526},{"_id":"source/categories/index.md","hash":"40838540000a938416765a823e3f83bcfe3393d3","modified":1712717821458},{"_id":"source/link/index.md","hash":"5356d4bfd7310b2282ce3402d7cd4e4c799c251d","modified":1712717930176},{"_id":"source/tags/index.md","hash":"32f0dad64d820455a0b07bea19e2fd84da28acba","modified":1712717644583},{"_id":"public/404.html","hash":"624760fa0cd07624cbdfce3e52e677821efd20a0","modified":1712845257055},{"_id":"public/categories/index.html","hash":"02a1ce16e73189c2e88bcd8b8968192ec8615740","modified":1712845257055},{"_id":"public/link/index.html","hash":"256103f3ddbad694f276f0339450965c679953ec","modified":1712845257055},{"_id":"public/tags/index.html","hash":"d31fdc72211a1d8d4e7f5c18e99fb05ccda1c4ba","modified":1712845257055},{"_id":"source/about/index.md","hash":"e73f4b93f0817e7fe57fb66c9408d33c7625a773","modified":1712718780557},{"_id":"source/_data/logo/mesh.png","hash":"f3f2952c8ce9746d53a5a6b8be035a5da68cf37c","modified":1712718686641},{"_id":"source/_data/signature/signature-removebg.png","hash":"ba5103eca83d60fd0682ad746442c48998b1c66f","modified":1712718686971},{"_id":"source/_data/avatar/2077_mobile.png","hash":"f5bba8aa0fd7a52106544451810c4da4a9c7b2c1","modified":1712718687471},{"_id":"public/about/index.html","hash":"59c269584a17bddc2051b9734df4a4ae54ce6ce0","modified":1712845257055},{"_id":"source/img/avatar/2077_mobile.png","hash":"f5bba8aa0fd7a52106544451810c4da4a9c7b2c1","modified":1712718687471},{"_id":"source/img/logo/mesh.png","hash":"f3f2952c8ce9746d53a5a6b8be035a5da68cf37c","modified":1712718686641},{"_id":"source/img/signature/signature-removebg.png","hash":"ba5103eca83d60fd0682ad746442c48998b1c66f","modified":1712718686971},{"_id":"public/img/logo/mesh.png","hash":"f3f2952c8ce9746d53a5a6b8be035a5da68cf37c","modified":1712722700433},{"_id":"public/img/signature/signature-removebg.png","hash":"ba5103eca83d60fd0682ad746442c48998b1c66f","modified":1712722700433},{"_id":"public/img/avatar/2077_mobile.png","hash":"f5bba8aa0fd7a52106544451810c4da4a9c7b2c1","modified":1712722700433},{"_id":"source/_posts/docker-with-butterfly.md","hash":"8fafbb12f9ea4b735d8bdae4a6b73affa2d67650","modified":1712722684036},{"_id":"public/docker-with-butterfly","hash":"8836b18264bfd0c7af05d4678ad3de4692a5ae3e","modified":1712722625951},{"_id":"public/2024/04/10/docker-with-butterfly/index.html","hash":"166364f78ad3723a37941354d41f38c1f9b65570","modified":1712722700433},{"_id":"source/_posts/2024/04/AI-Overview.md","hash":"59b7f35fcfbe83f97932e247cca7e149ac3208c5","modified":1712845164310},{"_id":"source/_posts/2024/04/CNI-Basic.md","hash":"92e9046a4709ae3f251fe94d61bd76f73d6ff972","modified":1712845225656},{"_id":"source/_posts/2024/04/create-cni.md","hash":"a03164fe244805fd5b4646bbbefcea5144e918f6","modified":1712845241807},{"_id":"source/_posts/2024/04/hexo-with-docker.md","hash":"9a9469b51e0b2c4b68833685d58231aa52beec64","modified":1712845160632},{"_id":"public/2024/04/11/create-cni/index.html","hash":"29f47c2d378e59d6da1c57c2a1497c7bed1d2eaf","modified":1712845257055},{"_id":"public/2024/04/11/hexo-with-docker/index.html","hash":"e424dd7b9983f55aa82403798ed404ef6a6b60a4","modified":1712845257055},{"_id":"public/categories/overview/index.html","hash":"8f205712c346c27e3104de0f15aea04d5ddc0e77","modified":1712845257055},{"_id":"public/categories/CNI/index.html","hash":"ec33065cfdfd9a09dd524ba3e8c0a41520b245a4","modified":1712827274296},{"_id":"public/tags/AI-overview/index.html","hash":"99cc7fb0ba2ca3a347184a3fd16f3de64a46b48e","modified":1712845257055},{"_id":"public/tags/ospp-CNI-Linux/index.html","hash":"f6acd629729fb087e642ec14540c5129e595ca45","modified":1712827274296},{"_id":"public/2024/04/11/CNI-Basic/index.html","hash":"3402440bf1aa8d679e78e734b28971f57f6a8d9d","modified":1712845257055},{"_id":"public/2024/04/11/AI-Overview/index.html","hash":"9800cfb4b248b6d5408e8ea4ac591ae951ef97e6","modified":1712845180066},{"_id":"source/_posts/2024/04/cni-pod.md","hash":"3b002df76937650e4d1d8e254f03fcdd47f4000d","modified":1712845235467},{"_id":"source/_posts/2024/04/cni-research.md","hash":"35fa59b26c7400ecafad3fd85611c9a0457169ae","modified":1712845238707},{"_id":"public/2024/04/11/cni-pod/index.html","hash":"561b7c51114da79bfb9f250ce8f58df4a6fa72a5","modified":1712845257055},{"_id":"public/2024/04/11/cni-research/index.html","hash":"78c324bfcfba0d0a7f88ba70173f0aeab4cb4c18","modified":1712845257055},{"_id":"public/categories/EdgeMesh/index.html","hash":"27f09be48f6bb4803ae70891b4add43b708cd125","modified":1712845257055},{"_id":"public/categories/Blog/index.html","hash":"e07d1b434e888df13a6b912635e9ebbb96e4bc2f","modified":1712845257055},{"_id":"public/tags/ospp-cni-Linux/index.html","hash":"65f25f1e7bf21a0edddd274ae46b37ab2b068703","modified":1712845257055},{"_id":"public/tags/Hexo-Blog-docker/index.html","hash":"b8980a48c8d0c8b126adfc0a08fa9d1c8dc7e32f","modified":1712845257055}],"Category":[{"name":"overview","_id":"cluv14vfd000252pe5tdf0lo3"},{"name":"CNI","_id":"cluv14vfg000552peck0h2rh0"},{"name":"EdgeMesh","_id":"cluvbsnor000182pe3uz83kj9"},{"name":"Blog","_id":"cluvbsnp1000c82pee1433tmd"}],"Data":[{"_id":"link","data":[{"class_name":"诸子百家","class_desc":"各位技术大佬们","link_list":[{"name":"ARTHURCHIAO","link":"https://arthurchiao.art/index.html","avatar":"https://avatars.githubusercontent.com/u/7912701?v=4","descr":"技术大佬"}]},{"class_name":"论坛博客","class_desc":"值得浏览的社区","link_list":[{"name":"medium","link":"https://medium.com/","avatar":"https://medium.design/logos-and-brand-guidelines-f1a01a733592","descr":"知识论坛"},{"name":"Data Science Blogathon","link":"https://www.analyticsvidhya.com/blog/","avatar":"/img/logo/mesh.png","descr":"AI知识论坛"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"分类","date":"2024-04-10T02:53:27.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2024-04-10 10:53:27\ntype: \"categories\"\n---\n","updated":"2024-04-10T02:57:01.458Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clut83rc80000dvrnatyyazmj","content":"","cover":false,"excerpt":"","more":""},{"title":"诸子百家","date":"2024-04-10T02:57:24.000Z","random":true,"type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 诸子百家\ndate: 2024-04-10 10:57:24\nrandom: true\ntype: link\n---\n","updated":"2024-04-10T02:58:50.176Z","path":"link/index.html","comments":1,"layout":"page","_id":"clut83rca0001dvrnb2amdcz7","content":"","cover":false,"excerpt":"","more":""},{"title":"标签","date":"2024-04-10T02:49:56.000Z","type":"tags","orderby":"name","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-04-10 10:49:56\ntype: \"tags\"\norderby: name\norder: 1\n---\n","updated":"2024-04-10T02:54:04.583Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clut83rca0002dvrnazv1ac4n","content":"","cover":false,"excerpt":"","more":""},{"title":"about","date":"2024-04-10T03:13:00.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-04-10 11:13:00\n---\n","updated":"2024-04-10T03:13:00.557Z","path":"about/index.html","comments":1,"layout":"page","_id":"clut8k3so00002kpeevz9254i","content":"","cover":false,"excerpt":"","more":""}],"Post":[{"title":"AI-Overview","date":"2024-04-11T08:16:29.000Z","description":"回顾 AI 大模型技术架构，从应用角度来理解系统服务","_content":"\n# 机器学习与大模型\n\n大语言模型是机器学习技术中自然语言处理（NLP）领域的一个实际应用，通过具备大规模参数的深度学习模型，对自然语言进行建模和生成，具备理解和生成自然语言文本的能力。其中这些大语言模型会使用不同的神经网络架构，如循环神经网络（RNN）、长短期记忆网络（LSTM）、门控循环单元（GRU）以及变换器（Transformer）等；他们可以看做是一个加工的盒子，通过输入大量的数据输出一个多参数集合的函数处理集合，这个集合就是大模型，它能够完成语言建模、文本分类、文本生成、机器翻译等工作，具体方式是给这个模型输入新的数据，通过这些多参数集合的函数处理后输出新的数据，然后将这些数据重新编码回自然语言。事实上，除了大语言模型，其他生成式的图片模型、视频模型等工作流程也类似。[^1] [^2]\n\n简单来说，机器学习是训练一段软件（称为模型model，实际就是一个具备大量参数的函数处理集合）以做出数据识别或从数据生成内容的过程。本质上来说，**模型是自机器学习系统通过各类方式抽象出来的数学关系**\n\n这样的方式是通过数学公式和方法去不断抽象数据及变化的特征，同时把这些特征转化为参数固定下来，比如模型需要关心一句问候语和回答语之间的关联性，就不断用大量这些类似语句转成数字集合，再把它们分别对应到定义域和值域，最终得到一个万用的公式。对于具备人类可观测的规律性和特征性事件，这类型的数学公式和模型就比较容易得到，最简单就是抛硬币的二项分布，这个公式和他的参数可以通过人脑模拟想象出来。\n\n但遇到复杂的情况，比如降雨、人脑思维、图片关系这些受到多维度因素影响的对应关系，很难直接用一个万用的数学模型去描述和归纳，而计算机算力的发展为选择数学模型和提取参数消除了在验证和选择方面的负担，用穷举的方式去遍历所有的可能（实际上更复杂一些）。即便无法想象，总可以试错，尝试数据对应的所有可能，就能选出合适的数学模型，不过这样的方式也总是难以直接用现有的数学理论来解释，在部分研究者中也称之为炼丹。\n\n\n## 机器学习系统的类型\n\n根据机器学习系统学习进行预测或生成内容的方式，机器学习系统可分为以下一个或多个类别：\n\n* 监督式学习\n* 非监督式学习\n* 强化学习\n* 生成式 AI\n\n### 监督式学习\n\n监督式学习模型指的是： 输入大量数据的同时指定正确的输出，只选择那些输出最接近正确答案的数学关系来组建模型。这样可以发现数据中生成正确答案的元素之间的关联，就像学生通过包含题目和答案的资料（参考答案），一旦刷的题和背的参考答案多了，就为参加新考试做好了充分的准备。\n\n监督式学习的两个最常见的使用场景是回归和分类。\n\n> 监督式机器学习基于以下核心概念：\n> Data： 数据集由包含特征和标签的各个样本组成。\n> Model： 定义从特定输入特征模式到特定输出标签值的数学关系。\n> Training：训练是找到特征与标签之间的数学关系\n> Evaluating: 评估经过训练的模型，以确定它的学习效果\n> Inference：推理是使用模型对无标签样本进行预测\n\n而这几个概念也是其他几类型学习的基础。\n\n### 非监督式学习\n\n非监督式学习模型指的是：输入大量数据进行计算，从中找到一个有意义的划分模式；换句话说，模型没有关于如何对每段数据进行分类的提示，而是必须推断自己的规则。\n\n### 强化学习\n强化学习模型通过基于在环境中执行的操作获取奖励或惩罚来进行训练，目标是找到能获得最多奖励的最佳策略。\n\n\n### 生成式 AI\n生成式 AI 是一类根据用户输入创建内容的模型。例如，生成式 AI 可以创作新颖的图像、乐曲和笑话，还可以总结文章、说明如何执行某项任务或编辑照片。\n\n生成式 AI 可以接受各种输入并创建各种输出，如文本、图片、音频和视频。它也可以接受并创建这些组合的组合。例如，模型可以将图片作为输入并创建图片和文本作为输出，或者将图片和文本作为输入并创建视频作为输出。\n\n按生成模型的输入和输出来讨论生成模型，通常写为“输入类型”到“输出类型”。例如，以下是生成模型的一些输入和输出的部分列表：\n\n* 文本到文本\n* 文本到图像\n* 文本到视频\n* 文本到代码\n* 文字转语音\n* 图片和文字到图片\n\n这类模型工作流程非常像是两张图片找不同，不过找的两张“图片”要替换成两个类型的数据集合，找不同也要变成找相似。[^3]\n\n> 这些流程中需要系统集中处理的是**训练** , **推理** 两个阶段\n> 高性能系统需要为这两个特定的功能需求提供服务。\n\n\n## 大语言模型\n\n目前的主流 AI 应用，以他为核心来讲讲相关技术。\n\n数学上，语言模型通过估算 token（就是英文当中的单词，当然也可能单词小，作用上是一个句子的组成单元） 或 token 序列在较长的token序列中出现的概率,然后计算不同完整句子或文本块的可能性，来执行生成句子、翻译语言以及回答问题等功能，一句话就是找一个可能性最高的 token 序列作为回答。\n\n这个模型可以是上述几类方法获取的，但是过程中对于系统资源和性能需求最高的训练和推理两个阶段；较大的 LLM 训练可能需要数月时间，同时使用超过 一万亿个参数的训练模型来推理也是个比较大的负担。[^5] [^6] [^7]\n\n首先概括训练前的准备，主要是将句子拆分成计算机能够识别的向量\n\n接下来拆解下训练的过程\n\n\n\n\n\n\n# 参考文献\n[^1]:[机器学习和人工智能基础知识](https://developers.google.com/machine-learning/resources/ml-ai-basics?hl=zh-cn)\n[^2]:[大型语言模型简介](https://developers.google.com/machine-learning/resources/intro-llms?hl=zh-cn)\n[^3]:[机器学习基础课程](https://developers.google.com/machine-learning/crash-course?hl=zh-cn)\n[^4]:[吴恩达机器学习](https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes)\n[^5]:[A_Beginner’s_Guide_to_Large_Language_Models](https://resources.nvidia.com/en-us-large-language-model-ebooks)\n[^6]:[什么是大型语言模型（LLM）](https://aws.amazon.com/cn/what-is/large-language-model/)\n[^7]:[Artificial_Intelligence_for_Beginners-A_Curriculum](https://microsoft.github.io/AI-For-Beginners/)\n[^8]:[Creating_a_Large_Language_Model_from_scratch:_A_beginner's_guide](https://github.com/Infatoshi/fcc-intro-to-llms)\n\n","source":"_posts/2024/04/AI-Overview.md","raw":"---\ntitle: AI-Overview\ndate: 2024-04-11 16:16:29\ntags: AI, overview\ncategories: overview\ndescription: \"回顾 AI 大模型技术架构，从应用角度来理解系统服务\"\n---\n\n# 机器学习与大模型\n\n大语言模型是机器学习技术中自然语言处理（NLP）领域的一个实际应用，通过具备大规模参数的深度学习模型，对自然语言进行建模和生成，具备理解和生成自然语言文本的能力。其中这些大语言模型会使用不同的神经网络架构，如循环神经网络（RNN）、长短期记忆网络（LSTM）、门控循环单元（GRU）以及变换器（Transformer）等；他们可以看做是一个加工的盒子，通过输入大量的数据输出一个多参数集合的函数处理集合，这个集合就是大模型，它能够完成语言建模、文本分类、文本生成、机器翻译等工作，具体方式是给这个模型输入新的数据，通过这些多参数集合的函数处理后输出新的数据，然后将这些数据重新编码回自然语言。事实上，除了大语言模型，其他生成式的图片模型、视频模型等工作流程也类似。[^1] [^2]\n\n简单来说，机器学习是训练一段软件（称为模型model，实际就是一个具备大量参数的函数处理集合）以做出数据识别或从数据生成内容的过程。本质上来说，**模型是自机器学习系统通过各类方式抽象出来的数学关系**\n\n这样的方式是通过数学公式和方法去不断抽象数据及变化的特征，同时把这些特征转化为参数固定下来，比如模型需要关心一句问候语和回答语之间的关联性，就不断用大量这些类似语句转成数字集合，再把它们分别对应到定义域和值域，最终得到一个万用的公式。对于具备人类可观测的规律性和特征性事件，这类型的数学公式和模型就比较容易得到，最简单就是抛硬币的二项分布，这个公式和他的参数可以通过人脑模拟想象出来。\n\n但遇到复杂的情况，比如降雨、人脑思维、图片关系这些受到多维度因素影响的对应关系，很难直接用一个万用的数学模型去描述和归纳，而计算机算力的发展为选择数学模型和提取参数消除了在验证和选择方面的负担，用穷举的方式去遍历所有的可能（实际上更复杂一些）。即便无法想象，总可以试错，尝试数据对应的所有可能，就能选出合适的数学模型，不过这样的方式也总是难以直接用现有的数学理论来解释，在部分研究者中也称之为炼丹。\n\n\n## 机器学习系统的类型\n\n根据机器学习系统学习进行预测或生成内容的方式，机器学习系统可分为以下一个或多个类别：\n\n* 监督式学习\n* 非监督式学习\n* 强化学习\n* 生成式 AI\n\n### 监督式学习\n\n监督式学习模型指的是： 输入大量数据的同时指定正确的输出，只选择那些输出最接近正确答案的数学关系来组建模型。这样可以发现数据中生成正确答案的元素之间的关联，就像学生通过包含题目和答案的资料（参考答案），一旦刷的题和背的参考答案多了，就为参加新考试做好了充分的准备。\n\n监督式学习的两个最常见的使用场景是回归和分类。\n\n> 监督式机器学习基于以下核心概念：\n> Data： 数据集由包含特征和标签的各个样本组成。\n> Model： 定义从特定输入特征模式到特定输出标签值的数学关系。\n> Training：训练是找到特征与标签之间的数学关系\n> Evaluating: 评估经过训练的模型，以确定它的学习效果\n> Inference：推理是使用模型对无标签样本进行预测\n\n而这几个概念也是其他几类型学习的基础。\n\n### 非监督式学习\n\n非监督式学习模型指的是：输入大量数据进行计算，从中找到一个有意义的划分模式；换句话说，模型没有关于如何对每段数据进行分类的提示，而是必须推断自己的规则。\n\n### 强化学习\n强化学习模型通过基于在环境中执行的操作获取奖励或惩罚来进行训练，目标是找到能获得最多奖励的最佳策略。\n\n\n### 生成式 AI\n生成式 AI 是一类根据用户输入创建内容的模型。例如，生成式 AI 可以创作新颖的图像、乐曲和笑话，还可以总结文章、说明如何执行某项任务或编辑照片。\n\n生成式 AI 可以接受各种输入并创建各种输出，如文本、图片、音频和视频。它也可以接受并创建这些组合的组合。例如，模型可以将图片作为输入并创建图片和文本作为输出，或者将图片和文本作为输入并创建视频作为输出。\n\n按生成模型的输入和输出来讨论生成模型，通常写为“输入类型”到“输出类型”。例如，以下是生成模型的一些输入和输出的部分列表：\n\n* 文本到文本\n* 文本到图像\n* 文本到视频\n* 文本到代码\n* 文字转语音\n* 图片和文字到图片\n\n这类模型工作流程非常像是两张图片找不同，不过找的两张“图片”要替换成两个类型的数据集合，找不同也要变成找相似。[^3]\n\n> 这些流程中需要系统集中处理的是**训练** , **推理** 两个阶段\n> 高性能系统需要为这两个特定的功能需求提供服务。\n\n\n## 大语言模型\n\n目前的主流 AI 应用，以他为核心来讲讲相关技术。\n\n数学上，语言模型通过估算 token（就是英文当中的单词，当然也可能单词小，作用上是一个句子的组成单元） 或 token 序列在较长的token序列中出现的概率,然后计算不同完整句子或文本块的可能性，来执行生成句子、翻译语言以及回答问题等功能，一句话就是找一个可能性最高的 token 序列作为回答。\n\n这个模型可以是上述几类方法获取的，但是过程中对于系统资源和性能需求最高的训练和推理两个阶段；较大的 LLM 训练可能需要数月时间，同时使用超过 一万亿个参数的训练模型来推理也是个比较大的负担。[^5] [^6] [^7]\n\n首先概括训练前的准备，主要是将句子拆分成计算机能够识别的向量\n\n接下来拆解下训练的过程\n\n\n\n\n\n\n# 参考文献\n[^1]:[机器学习和人工智能基础知识](https://developers.google.com/machine-learning/resources/ml-ai-basics?hl=zh-cn)\n[^2]:[大型语言模型简介](https://developers.google.com/machine-learning/resources/intro-llms?hl=zh-cn)\n[^3]:[机器学习基础课程](https://developers.google.com/machine-learning/crash-course?hl=zh-cn)\n[^4]:[吴恩达机器学习](https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes)\n[^5]:[A_Beginner’s_Guide_to_Large_Language_Models](https://resources.nvidia.com/en-us-large-language-model-ebooks)\n[^6]:[什么是大型语言模型（LLM）](https://aws.amazon.com/cn/what-is/large-language-model/)\n[^7]:[Artificial_Intelligence_for_Beginners-A_Curriculum](https://microsoft.github.io/AI-For-Beginners/)\n[^8]:[Creating_a_Large_Language_Model_from_scratch:_A_beginner's_guide](https://github.com/Infatoshi/fcc-intro-to-llms)\n\n","slug":"AI-Overview","published":1,"updated":"2024-04-11T14:19:24.310Z","_id":"cluv14vf7000052pe1ogs48zx","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"机器学习与大模型\"><a href=\"#机器学习与大模型\" class=\"headerlink\" title=\"机器学习与大模型\"></a>机器学习与大模型</h1><p>大语言模型是机器学习技术中自然语言处理（NLP）领域的一个实际应用，通过具备大规模参数的深度学习模型，对自然语言进行建模和生成，具备理解和生成自然语言文本的能力。其中这些大语言模型会使用不同的神经网络架构，如循环神经网络（RNN）、长短期记忆网络（LSTM）、门控循环单元（GRU）以及变换器（Transformer）等；他们可以看做是一个加工的盒子，通过输入大量的数据输出一个多参数集合的函数处理集合，这个集合就是大模型，它能够完成语言建模、文本分类、文本生成、机器翻译等工作，具体方式是给这个模型输入新的数据，通过这些多参数集合的函数处理后输出新的数据，然后将这些数据重新编码回自然语言。事实上，除了大语言模型，其他生成式的图片模型、视频模型等工作流程也类似。<a href=\"%5B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5D(https://developers.google.com/machine-learning/resources/ml-ai-basics?hl=zh-cn)\">^1</a> <a href=\"%5B%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B%5D(https://developers.google.com/machine-learning/resources/intro-llms?hl=zh-cn)\">^2</a></p>\n<p>简单来说，机器学习是训练一段软件（称为模型model，实际就是一个具备大量参数的函数处理集合）以做出数据识别或从数据生成内容的过程。本质上来说，<strong>模型是自机器学习系统通过各类方式抽象出来的数学关系</strong></p>\n<p>这样的方式是通过数学公式和方法去不断抽象数据及变化的特征，同时把这些特征转化为参数固定下来，比如模型需要关心一句问候语和回答语之间的关联性，就不断用大量这些类似语句转成数字集合，再把它们分别对应到定义域和值域，最终得到一个万用的公式。对于具备人类可观测的规律性和特征性事件，这类型的数学公式和模型就比较容易得到，最简单就是抛硬币的二项分布，这个公式和他的参数可以通过人脑模拟想象出来。</p>\n<p>但遇到复杂的情况，比如降雨、人脑思维、图片关系这些受到多维度因素影响的对应关系，很难直接用一个万用的数学模型去描述和归纳，而计算机算力的发展为选择数学模型和提取参数消除了在验证和选择方面的负担，用穷举的方式去遍历所有的可能（实际上更复杂一些）。即便无法想象，总可以试错，尝试数据对应的所有可能，就能选出合适的数学模型，不过这样的方式也总是难以直接用现有的数学理论来解释，在部分研究者中也称之为炼丹。</p>\n<h2 id=\"机器学习系统的类型\"><a href=\"#机器学习系统的类型\" class=\"headerlink\" title=\"机器学习系统的类型\"></a>机器学习系统的类型</h2><p>根据机器学习系统学习进行预测或生成内容的方式，机器学习系统可分为以下一个或多个类别：</p>\n<ul>\n<li>监督式学习</li>\n<li>非监督式学习</li>\n<li>强化学习</li>\n<li>生成式 AI</li>\n</ul>\n<h3 id=\"监督式学习\"><a href=\"#监督式学习\" class=\"headerlink\" title=\"监督式学习\"></a>监督式学习</h3><p>监督式学习模型指的是： 输入大量数据的同时指定正确的输出，只选择那些输出最接近正确答案的数学关系来组建模型。这样可以发现数据中生成正确答案的元素之间的关联，就像学生通过包含题目和答案的资料（参考答案），一旦刷的题和背的参考答案多了，就为参加新考试做好了充分的准备。</p>\n<p>监督式学习的两个最常见的使用场景是回归和分类。</p>\n<blockquote>\n<p>监督式机器学习基于以下核心概念：<br>Data： 数据集由包含特征和标签的各个样本组成。<br>Model： 定义从特定输入特征模式到特定输出标签值的数学关系。<br>Training：训练是找到特征与标签之间的数学关系<br>Evaluating: 评估经过训练的模型，以确定它的学习效果<br>Inference：推理是使用模型对无标签样本进行预测</p>\n</blockquote>\n<p>而这几个概念也是其他几类型学习的基础。</p>\n<h3 id=\"非监督式学习\"><a href=\"#非监督式学习\" class=\"headerlink\" title=\"非监督式学习\"></a>非监督式学习</h3><p>非监督式学习模型指的是：输入大量数据进行计算，从中找到一个有意义的划分模式；换句话说，模型没有关于如何对每段数据进行分类的提示，而是必须推断自己的规则。</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>强化学习模型通过基于在环境中执行的操作获取奖励或惩罚来进行训练，目标是找到能获得最多奖励的最佳策略。</p>\n<h3 id=\"生成式-AI\"><a href=\"#生成式-AI\" class=\"headerlink\" title=\"生成式 AI\"></a>生成式 AI</h3><p>生成式 AI 是一类根据用户输入创建内容的模型。例如，生成式 AI 可以创作新颖的图像、乐曲和笑话，还可以总结文章、说明如何执行某项任务或编辑照片。</p>\n<p>生成式 AI 可以接受各种输入并创建各种输出，如文本、图片、音频和视频。它也可以接受并创建这些组合的组合。例如，模型可以将图片作为输入并创建图片和文本作为输出，或者将图片和文本作为输入并创建视频作为输出。</p>\n<p>按生成模型的输入和输出来讨论生成模型，通常写为“输入类型”到“输出类型”。例如，以下是生成模型的一些输入和输出的部分列表：</p>\n<ul>\n<li>文本到文本</li>\n<li>文本到图像</li>\n<li>文本到视频</li>\n<li>文本到代码</li>\n<li>文字转语音</li>\n<li>图片和文字到图片</li>\n</ul>\n<p>这类模型工作流程非常像是两张图片找不同，不过找的两张“图片”要替换成两个类型的数据集合，找不同也要变成找相似。<a href=\"%5B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%5D(https://developers.google.com/machine-learning/crash-course?hl=zh-cn)\">^3</a></p>\n<blockquote>\n<p>这些流程中需要系统集中处理的是<strong>训练</strong> , <strong>推理</strong> 两个阶段<br>高性能系统需要为这两个特定的功能需求提供服务。</p>\n</blockquote>\n<h2 id=\"大语言模型\"><a href=\"#大语言模型\" class=\"headerlink\" title=\"大语言模型\"></a>大语言模型</h2><p>目前的主流 AI 应用，以他为核心来讲讲相关技术。</p>\n<p>数学上，语言模型通过估算 token（就是英文当中的单词，当然也可能单词小，作用上是一个句子的组成单元） 或 token 序列在较长的token序列中出现的概率,然后计算不同完整句子或文本块的可能性，来执行生成句子、翻译语言以及回答问题等功能，一句话就是找一个可能性最高的 token 序列作为回答。</p>\n<p>这个模型可以是上述几类方法获取的，但是过程中对于系统资源和性能需求最高的训练和推理两个阶段；较大的 LLM 训练可能需要数月时间，同时使用超过 一万亿个参数的训练模型来推理也是个比较大的负担。<a href=\"%5BA_Beginner%E2%80%99s_Guide_to_Large_Language_Models%5D(https://resources.nvidia.com/en-us-large-language-model-ebooks)\">^5</a> <a href=\"%5B%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89%5D(https://aws.amazon.com/cn/what-is/large-language-model/)\">^6</a> <a href=\"%5BArtificial_Intelligence_for_Beginners-A_Curriculum%5D(https://microsoft.github.io/AI-For-Beginners/)\">^7</a></p>\n<p>首先概括训练前的准备，主要是将句子拆分成计算机能够识别的向量</p>\n<p>接下来拆解下训练的过程</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1>","cover":false,"excerpt":"","more":"<h1 id=\"机器学习与大模型\"><a href=\"#机器学习与大模型\" class=\"headerlink\" title=\"机器学习与大模型\"></a>机器学习与大模型</h1><p>大语言模型是机器学习技术中自然语言处理（NLP）领域的一个实际应用，通过具备大规模参数的深度学习模型，对自然语言进行建模和生成，具备理解和生成自然语言文本的能力。其中这些大语言模型会使用不同的神经网络架构，如循环神经网络（RNN）、长短期记忆网络（LSTM）、门控循环单元（GRU）以及变换器（Transformer）等；他们可以看做是一个加工的盒子，通过输入大量的数据输出一个多参数集合的函数处理集合，这个集合就是大模型，它能够完成语言建模、文本分类、文本生成、机器翻译等工作，具体方式是给这个模型输入新的数据，通过这些多参数集合的函数处理后输出新的数据，然后将这些数据重新编码回自然语言。事实上，除了大语言模型，其他生成式的图片模型、视频模型等工作流程也类似。<a href=\"%5B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5D(https://developers.google.com/machine-learning/resources/ml-ai-basics?hl=zh-cn)\">^1</a> <a href=\"%5B%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B%5D(https://developers.google.com/machine-learning/resources/intro-llms?hl=zh-cn)\">^2</a></p>\n<p>简单来说，机器学习是训练一段软件（称为模型model，实际就是一个具备大量参数的函数处理集合）以做出数据识别或从数据生成内容的过程。本质上来说，<strong>模型是自机器学习系统通过各类方式抽象出来的数学关系</strong></p>\n<p>这样的方式是通过数学公式和方法去不断抽象数据及变化的特征，同时把这些特征转化为参数固定下来，比如模型需要关心一句问候语和回答语之间的关联性，就不断用大量这些类似语句转成数字集合，再把它们分别对应到定义域和值域，最终得到一个万用的公式。对于具备人类可观测的规律性和特征性事件，这类型的数学公式和模型就比较容易得到，最简单就是抛硬币的二项分布，这个公式和他的参数可以通过人脑模拟想象出来。</p>\n<p>但遇到复杂的情况，比如降雨、人脑思维、图片关系这些受到多维度因素影响的对应关系，很难直接用一个万用的数学模型去描述和归纳，而计算机算力的发展为选择数学模型和提取参数消除了在验证和选择方面的负担，用穷举的方式去遍历所有的可能（实际上更复杂一些）。即便无法想象，总可以试错，尝试数据对应的所有可能，就能选出合适的数学模型，不过这样的方式也总是难以直接用现有的数学理论来解释，在部分研究者中也称之为炼丹。</p>\n<h2 id=\"机器学习系统的类型\"><a href=\"#机器学习系统的类型\" class=\"headerlink\" title=\"机器学习系统的类型\"></a>机器学习系统的类型</h2><p>根据机器学习系统学习进行预测或生成内容的方式，机器学习系统可分为以下一个或多个类别：</p>\n<ul>\n<li>监督式学习</li>\n<li>非监督式学习</li>\n<li>强化学习</li>\n<li>生成式 AI</li>\n</ul>\n<h3 id=\"监督式学习\"><a href=\"#监督式学习\" class=\"headerlink\" title=\"监督式学习\"></a>监督式学习</h3><p>监督式学习模型指的是： 输入大量数据的同时指定正确的输出，只选择那些输出最接近正确答案的数学关系来组建模型。这样可以发现数据中生成正确答案的元素之间的关联，就像学生通过包含题目和答案的资料（参考答案），一旦刷的题和背的参考答案多了，就为参加新考试做好了充分的准备。</p>\n<p>监督式学习的两个最常见的使用场景是回归和分类。</p>\n<blockquote>\n<p>监督式机器学习基于以下核心概念：<br>Data： 数据集由包含特征和标签的各个样本组成。<br>Model： 定义从特定输入特征模式到特定输出标签值的数学关系。<br>Training：训练是找到特征与标签之间的数学关系<br>Evaluating: 评估经过训练的模型，以确定它的学习效果<br>Inference：推理是使用模型对无标签样本进行预测</p>\n</blockquote>\n<p>而这几个概念也是其他几类型学习的基础。</p>\n<h3 id=\"非监督式学习\"><a href=\"#非监督式学习\" class=\"headerlink\" title=\"非监督式学习\"></a>非监督式学习</h3><p>非监督式学习模型指的是：输入大量数据进行计算，从中找到一个有意义的划分模式；换句话说，模型没有关于如何对每段数据进行分类的提示，而是必须推断自己的规则。</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>强化学习模型通过基于在环境中执行的操作获取奖励或惩罚来进行训练，目标是找到能获得最多奖励的最佳策略。</p>\n<h3 id=\"生成式-AI\"><a href=\"#生成式-AI\" class=\"headerlink\" title=\"生成式 AI\"></a>生成式 AI</h3><p>生成式 AI 是一类根据用户输入创建内容的模型。例如，生成式 AI 可以创作新颖的图像、乐曲和笑话，还可以总结文章、说明如何执行某项任务或编辑照片。</p>\n<p>生成式 AI 可以接受各种输入并创建各种输出，如文本、图片、音频和视频。它也可以接受并创建这些组合的组合。例如，模型可以将图片作为输入并创建图片和文本作为输出，或者将图片和文本作为输入并创建视频作为输出。</p>\n<p>按生成模型的输入和输出来讨论生成模型，通常写为“输入类型”到“输出类型”。例如，以下是生成模型的一些输入和输出的部分列表：</p>\n<ul>\n<li>文本到文本</li>\n<li>文本到图像</li>\n<li>文本到视频</li>\n<li>文本到代码</li>\n<li>文字转语音</li>\n<li>图片和文字到图片</li>\n</ul>\n<p>这类模型工作流程非常像是两张图片找不同，不过找的两张“图片”要替换成两个类型的数据集合，找不同也要变成找相似。<a href=\"%5B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%5D(https://developers.google.com/machine-learning/crash-course?hl=zh-cn)\">^3</a></p>\n<blockquote>\n<p>这些流程中需要系统集中处理的是<strong>训练</strong> , <strong>推理</strong> 两个阶段<br>高性能系统需要为这两个特定的功能需求提供服务。</p>\n</blockquote>\n<h2 id=\"大语言模型\"><a href=\"#大语言模型\" class=\"headerlink\" title=\"大语言模型\"></a>大语言模型</h2><p>目前的主流 AI 应用，以他为核心来讲讲相关技术。</p>\n<p>数学上，语言模型通过估算 token（就是英文当中的单词，当然也可能单词小，作用上是一个句子的组成单元） 或 token 序列在较长的token序列中出现的概率,然后计算不同完整句子或文本块的可能性，来执行生成句子、翻译语言以及回答问题等功能，一句话就是找一个可能性最高的 token 序列作为回答。</p>\n<p>这个模型可以是上述几类方法获取的，但是过程中对于系统资源和性能需求最高的训练和推理两个阶段；较大的 LLM 训练可能需要数月时间，同时使用超过 一万亿个参数的训练模型来推理也是个比较大的负担。<a href=\"%5BA_Beginner%E2%80%99s_Guide_to_Large_Language_Models%5D(https://resources.nvidia.com/en-us-large-language-model-ebooks)\">^5</a> <a href=\"%5B%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89%5D(https://aws.amazon.com/cn/what-is/large-language-model/)\">^6</a> <a href=\"%5BArtificial_Intelligence_for_Beginners-A_Curriculum%5D(https://microsoft.github.io/AI-For-Beginners/)\">^7</a></p>\n<p>首先概括训练前的准备，主要是将句子拆分成计算机能够识别的向量</p>\n<p>接下来拆解下训练的过程</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1>"},{"title":"Kubernetes 容器网络 — CNI","date":"2024-04-11T09:16:32.000Z","catalog":true,"_content":"\n\n# CNI 概述\n\n## 什么是 CNI \n\n> CNI的全称是 Container Network Interface，它为**容器提供了一种基于插件结构的标准化网络解决方案**。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。**CNI从网络服务里抽象出了一套标准接口**，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。\n\n首先 CNI 是一套标准接口，它隶属于[CNCF(Cloud Native Computing Foundation)](https://cncf.io/)，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。\n\n其次 依据 CNI 的[规范](https://github.com/containernetworking/cni/blob/master/SPEC.md)，CNI 具有以下几点特征：\n\n- CNI 需提供网络管理员**定义网络配置的文件格式**\n- CNI 需提供 Container Runtime（CRI） 调用功能的**协议/API**。\n- 当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能\n- CNI 需预留可调用其他插件的能力\n- CNI 需规范统一返回给CRI 的数据格式\n\n依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：\n\n* 可执行文件\n  * CNI 主进程\n  * IPAM 等\n* 网络配置文件\n\n---\n\n## CNI 的功能\n\nCNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供**基础的 Linux 网络联通服务**，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后**将IP 分配给接口**，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。\n\n那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准\n\n---\n\n\n\n## CNI 统一的网络配置文件\n\nCNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。\n\n一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：\n\n- `cniVersion`: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此\n- `Name`: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。\n- `disableCheck`: 是否禁用检查网络，如果为true,则 `container runtime` 不会调用 Check 方法进行网络检查。\n- `plugin`: cni插件及其配置列表，可以配置多个插件。\n\n接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理\n\n1. 必须配置的键值\n\n   `type` :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引\n\n   至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能\n\n2. 可选键值，由 CRI 依据协议发送的 request 指定\n\n   `capabilities`:  如果 CNI_ARGS 中没有指定此项功能时候来补充的\n\n3. 预留键值，由 CRI 在执行时产生的\n\n   - `runtimeConfig` :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。\n   - `args`\n   - 或者是任何以 `cni.dev/`开头的\n\n4. 可选键值,由容器网络管理员添加\n\n   `ipMasq`: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。\n\n   当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。\n\n   `ipam`: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件\n\n   > 例子1当中：\n   >\n   > - type：指定所用IPAM插件的名称，在例子里，用的是host-local。\n   > - subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为`10.15.10.0/24`，也就是目标网段为`10.15.10.0`，子网掩码为`255.255.255.0`。\n   > - routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为`0.0.0.0/0`则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。\n   > - rangeStart：允许分配的IP地址范围的起始值\n   > - rangeEnd：允许分配的IP地址范围的结束值\n   > - gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。\n\n配置文件例子如下：\n\n例子1：\n\n```json\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\n```\n\n例子2：\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n---\n\n\n\n## CNI 运行时协议\n\nCNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。\n\n主要的协议参数定义如下：\n\n* CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。\n* CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。\n* CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。\n* CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。\n* CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，\"FOO=BAR;ABC=123\"\n* CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的':'和Windows上的'；'。\n\n告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。\n\n对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：\n\n* ADD\n\n  - 将容器添加到网络中，或将新的配置修改应用到已有的集群当中。\n\n  - 一个CNI插件在收到ADD命令后，应该选择\n\n    - 在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，\n\n    - 调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置\n\n      如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。\n\n* DELETE\n\n  * 将容器删除出网络，或将新的配置修改应用到已有的集群当中。\n\n    功能与ADD 相对\n\n* CHECK\n\n  * 查找类型字段中指定的可执行文件，如果没找到返回错误\n  * 当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者\n\n---\n\n\n\n## CNI 与插件\n\n为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。\n\n一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 `ADD`,`DELETE`。 \n\nCNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 `CNI_PATH`之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。\n\n如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。\n\n---\n\n# CNI 配置文件样例\n\n> 参考[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md) 的 Appendix: Examples\n\n借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n### Add example\n\nThe container runtime would perform the following steps for the `add` operation.\n\n1. Call the `bridge` plugin with the following JSON, `CNI_COMMAND=ADD`:\n\n```\n{\n    \"cniVersion\": \"1.0.0\",\n    \"name\": \"dbnet\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\"\n    },\n    \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\nThe bridge plugin, as it delegates IPAM to the `host-local` plugin, would execute the `host-local` binary with the exact same input, `CNI_COMMAND=ADD`.\n\nThe `host-local` plugin returns the following result:\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\"\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\nThe bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n1. Next, call the `tuning` plugin, with `CNI_COMMAND=ADD`. Note that `prevResult` is supplied, along with the `mac` capability argument. The request configuration passed is:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe plugin returns the following result. Note that the **mac** has changed.\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n1. Finally, call the `portmap` plugin, with `CNI_COMMAND=ADD`. Note that `prevResult` matches that returned by `tuning`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe `portmap` plugin outputs the exact same result as that returned by `bridge`, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).\n\n### Check example\n\nGiven the previous *Add*, the container runtime would perform the following steps for the *Check* action:\n\n1. First call the `bridge` plugin with the following request configuration, including the `prevResult` field containing the final JSON response from the *Add* operation, **including the changed mac**. `CNI_COMMAND=CHECK`\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  \"bridge\": \"cni0\",\n  \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n  \"ipam\": {\n    \"type\": \"host-local\",\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [ \"10.1.0.1\" ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe `bridge` plugin, as it delegates IPAM, calls `host-local`, `CNI_COMMAND=CHECK`. It returns no error.\n\nAssuming the `bridge` plugin is satisfied, it produces no output on standard out and exits with a 0 return code.\n\n1. Next call the `tuning` plugin with the following request configuration:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nLikewise, the `tuning` plugin exits indicating success.\n\n1. Finally, call `portmap` with the following request configuration:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n### Delete example\n\nGiven the same network configuration JSON list, the container runtime would perform the following steps for the *Delete* action. Note that plugins are executed in reverse order from the *Add* and *Check* actions.\n\n1. First, call `portmap` with the following request configuration, `CNI_COMMAND=DEL`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n1. Next, call the `tuning` plugin with the following request configuration, `CNI_COMMAND=DEL`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n1. Finally, call `bridge`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  \"bridge\": \"cni0\",\n  \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n  \"ipam\": {\n    \"type\": \"host-local\",\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [ \"10.1.0.1\" ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe bridge plugin executes the `host-local` delegated plugin with `CNI_COMMAND=DEL` before returning.\n\n---\n\n\n\n## 相关仓库及文献\n\n[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md)\n\n[Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)](https://lengrongfu.github.io/2022-05-11-k8s之CNI规范解读/)\n\n[A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)](https://www.redhat.com/sysadmin/cni-kubernetes)\n\n[Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli)\n\n[Network Plugins | Kubernetes](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)\n\n[Kubernetes CNI Explained (tigera.io)](https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/)\n\n","source":"_posts/2024/04/CNI-Basic.md","raw":"---\ntitle: Kubernetes 容器网络 — CNI\ndate: 2024-04-11 17:16:32\ntags: ospp, cni, Linux\ncategories: EdgeMesh\ncatalog: true\n---\n\n\n# CNI 概述\n\n## 什么是 CNI \n\n> CNI的全称是 Container Network Interface，它为**容器提供了一种基于插件结构的标准化网络解决方案**。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。**CNI从网络服务里抽象出了一套标准接口**，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。\n\n首先 CNI 是一套标准接口，它隶属于[CNCF(Cloud Native Computing Foundation)](https://cncf.io/)，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。\n\n其次 依据 CNI 的[规范](https://github.com/containernetworking/cni/blob/master/SPEC.md)，CNI 具有以下几点特征：\n\n- CNI 需提供网络管理员**定义网络配置的文件格式**\n- CNI 需提供 Container Runtime（CRI） 调用功能的**协议/API**。\n- 当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能\n- CNI 需预留可调用其他插件的能力\n- CNI 需规范统一返回给CRI 的数据格式\n\n依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：\n\n* 可执行文件\n  * CNI 主进程\n  * IPAM 等\n* 网络配置文件\n\n---\n\n## CNI 的功能\n\nCNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供**基础的 Linux 网络联通服务**，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后**将IP 分配给接口**，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。\n\n那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准\n\n---\n\n\n\n## CNI 统一的网络配置文件\n\nCNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。\n\n一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：\n\n- `cniVersion`: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此\n- `Name`: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。\n- `disableCheck`: 是否禁用检查网络，如果为true,则 `container runtime` 不会调用 Check 方法进行网络检查。\n- `plugin`: cni插件及其配置列表，可以配置多个插件。\n\n接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理\n\n1. 必须配置的键值\n\n   `type` :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引\n\n   至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能\n\n2. 可选键值，由 CRI 依据协议发送的 request 指定\n\n   `capabilities`:  如果 CNI_ARGS 中没有指定此项功能时候来补充的\n\n3. 预留键值，由 CRI 在执行时产生的\n\n   - `runtimeConfig` :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。\n   - `args`\n   - 或者是任何以 `cni.dev/`开头的\n\n4. 可选键值,由容器网络管理员添加\n\n   `ipMasq`: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。\n\n   当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。\n\n   `ipam`: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件\n\n   > 例子1当中：\n   >\n   > - type：指定所用IPAM插件的名称，在例子里，用的是host-local。\n   > - subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为`10.15.10.0/24`，也就是目标网段为`10.15.10.0`，子网掩码为`255.255.255.0`。\n   > - routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为`0.0.0.0/0`则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。\n   > - rangeStart：允许分配的IP地址范围的起始值\n   > - rangeEnd：允许分配的IP地址范围的结束值\n   > - gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。\n\n配置文件例子如下：\n\n例子1：\n\n```json\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\n```\n\n例子2：\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n---\n\n\n\n## CNI 运行时协议\n\nCNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。\n\n主要的协议参数定义如下：\n\n* CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。\n* CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。\n* CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。\n* CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。\n* CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，\"FOO=BAR;ABC=123\"\n* CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的':'和Windows上的'；'。\n\n告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。\n\n对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：\n\n* ADD\n\n  - 将容器添加到网络中，或将新的配置修改应用到已有的集群当中。\n\n  - 一个CNI插件在收到ADD命令后，应该选择\n\n    - 在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，\n\n    - 调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置\n\n      如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。\n\n* DELETE\n\n  * 将容器删除出网络，或将新的配置修改应用到已有的集群当中。\n\n    功能与ADD 相对\n\n* CHECK\n\n  * 查找类型字段中指定的可执行文件，如果没找到返回错误\n  * 当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者\n\n---\n\n\n\n## CNI 与插件\n\n为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。\n\n一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 `ADD`,`DELETE`。 \n\nCNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 `CNI_PATH`之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。\n\n如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。\n\n---\n\n# CNI 配置文件样例\n\n> 参考[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md) 的 Appendix: Examples\n\n借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n### Add example\n\nThe container runtime would perform the following steps for the `add` operation.\n\n1. Call the `bridge` plugin with the following JSON, `CNI_COMMAND=ADD`:\n\n```\n{\n    \"cniVersion\": \"1.0.0\",\n    \"name\": \"dbnet\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\"\n    },\n    \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\nThe bridge plugin, as it delegates IPAM to the `host-local` plugin, would execute the `host-local` binary with the exact same input, `CNI_COMMAND=ADD`.\n\nThe `host-local` plugin returns the following result:\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\"\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\nThe bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n1. Next, call the `tuning` plugin, with `CNI_COMMAND=ADD`. Note that `prevResult` is supplied, along with the `mac` capability argument. The request configuration passed is:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe plugin returns the following result. Note that the **mac** has changed.\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n1. Finally, call the `portmap` plugin, with `CNI_COMMAND=ADD`. Note that `prevResult` matches that returned by `tuning`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe `portmap` plugin outputs the exact same result as that returned by `bridge`, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).\n\n### Check example\n\nGiven the previous *Add*, the container runtime would perform the following steps for the *Check* action:\n\n1. First call the `bridge` plugin with the following request configuration, including the `prevResult` field containing the final JSON response from the *Add* operation, **including the changed mac**. `CNI_COMMAND=CHECK`\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  \"bridge\": \"cni0\",\n  \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n  \"ipam\": {\n    \"type\": \"host-local\",\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [ \"10.1.0.1\" ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe `bridge` plugin, as it delegates IPAM, calls `host-local`, `CNI_COMMAND=CHECK`. It returns no error.\n\nAssuming the `bridge` plugin is satisfied, it produces no output on standard out and exits with a 0 return code.\n\n1. Next call the `tuning` plugin with the following request configuration:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nLikewise, the `tuning` plugin exits indicating success.\n\n1. Finally, call `portmap` with the following request configuration:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n### Delete example\n\nGiven the same network configuration JSON list, the container runtime would perform the following steps for the *Delete* action. Note that plugins are executed in reverse order from the *Add* and *Check* actions.\n\n1. First, call `portmap` with the following request configuration, `CNI_COMMAND=DEL`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n1. Next, call the `tuning` plugin with the following request configuration, `CNI_COMMAND=DEL`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n1. Finally, call `bridge`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  \"bridge\": \"cni0\",\n  \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n  \"ipam\": {\n    \"type\": \"host-local\",\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [ \"10.1.0.1\" ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe bridge plugin executes the `host-local` delegated plugin with `CNI_COMMAND=DEL` before returning.\n\n---\n\n\n\n## 相关仓库及文献\n\n[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md)\n\n[Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)](https://lengrongfu.github.io/2022-05-11-k8s之CNI规范解读/)\n\n[A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)](https://www.redhat.com/sysadmin/cni-kubernetes)\n\n[Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli)\n\n[Network Plugins | Kubernetes](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)\n\n[Kubernetes CNI Explained (tigera.io)](https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/)\n\n","slug":"CNI-Basic","published":1,"updated":"2024-04-11T14:20:25.656Z","_id":"cluv14vfc000152peb33e2u5g","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"CNI-概述\"><a href=\"#CNI-概述\" class=\"headerlink\" title=\"CNI 概述\"></a>CNI 概述</h1><h2 id=\"什么是-CNI\"><a href=\"#什么是-CNI\" class=\"headerlink\" title=\"什么是 CNI\"></a>什么是 CNI</h2><blockquote>\n<p>CNI的全称是 Container Network Interface，它为<strong>容器提供了一种基于插件结构的标准化网络解决方案</strong>。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。<strong>CNI从网络服务里抽象出了一套标准接口</strong>，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。</p>\n</blockquote>\n<p>首先 CNI 是一套标准接口，它隶属于<a href=\"https://cncf.io/\">CNCF(Cloud Native Computing Foundation)</a>，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p>\n<p>其次 依据 CNI 的<a href=\"https://github.com/containernetworking/cni/blob/master/SPEC.md\">规范</a>，CNI 具有以下几点特征：</p>\n<ul>\n<li>CNI 需提供网络管理员<strong>定义网络配置的文件格式</strong></li>\n<li>CNI 需提供 Container Runtime（CRI） 调用功能的<strong>协议&#x2F;API</strong>。</li>\n<li>当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能</li>\n<li>CNI 需预留可调用其他插件的能力</li>\n<li>CNI 需规范统一返回给CRI 的数据格式</li>\n</ul>\n<p>依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：</p>\n<ul>\n<li>可执行文件<ul>\n<li>CNI 主进程</li>\n<li>IPAM 等</li>\n</ul>\n</li>\n<li>网络配置文件</li>\n</ul>\n<hr>\n<h2 id=\"CNI-的功能\"><a href=\"#CNI-的功能\" class=\"headerlink\" title=\"CNI 的功能\"></a>CNI 的功能</h2><p>CNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供<strong>基础的 Linux 网络联通服务</strong>，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后<strong>将IP 分配给接口</strong>，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。</p>\n<p>那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准</p>\n<hr>\n<h2 id=\"CNI-统一的网络配置文件\"><a href=\"#CNI-统一的网络配置文件\" class=\"headerlink\" title=\"CNI 统一的网络配置文件\"></a>CNI 统一的网络配置文件</h2><p>CNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。</p>\n<p>一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：</p>\n<ul>\n<li><code>cniVersion</code>: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此</li>\n<li><code>Name</code>: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。</li>\n<li><code>disableCheck</code>: 是否禁用检查网络，如果为true,则 <code>container runtime</code> 不会调用 Check 方法进行网络检查。</li>\n<li><code>plugin</code>: cni插件及其配置列表，可以配置多个插件。</li>\n</ul>\n<p>接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理</p>\n<ol>\n<li><p>必须配置的键值</p>\n<p><code>type</code> :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引</p>\n<p>至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能</p>\n</li>\n<li><p>可选键值，由 CRI 依据协议发送的 request 指定</p>\n<p><code>capabilities</code>:  如果 CNI_ARGS 中没有指定此项功能时候来补充的</p>\n</li>\n<li><p>预留键值，由 CRI 在执行时产生的</p>\n<ul>\n<li><code>runtimeConfig</code> :  比如 CNI 自己设置的 isGateway &#x3D;&#x3D; true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。</li>\n<li><code>args</code></li>\n<li>或者是任何以 <code>cni.dev/</code>开头的</li>\n</ul>\n</li>\n<li><p>可选键值,由容器网络管理员添加</p>\n<p><code>ipMasq</code>: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。</p>\n<p>当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。</p>\n<p><code>ipam</code>: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件</p>\n<blockquote>\n<p>例子1当中：</p>\n<ul>\n<li>type：指定所用IPAM插件的名称，在例子里，用的是host-local。</li>\n<li>subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为<code>10.15.10.0/24</code>，也就是目标网段为<code>10.15.10.0</code>，子网掩码为<code>255.255.255.0</code>。</li>\n<li>routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为<code>0.0.0.0/0</code>则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</li>\n<li>rangeStart：允许分配的IP地址范围的起始值</li>\n<li>rangeEnd：允许分配的IP地址范围的结束值</li>\n<li>gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>配置文件例子如下：</p>\n<p>例子1：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.4.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;isGateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipMasq&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.0/24&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span> <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeStart&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.100&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeEnd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.200&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>例子2：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"CNI-运行时协议\"><a href=\"#CNI-运行时协议\" class=\"headerlink\" title=\"CNI 运行时协议\"></a>CNI 运行时协议</h2><p>CNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。</p>\n<p>主要的协议参数定义如下：</p>\n<ul>\n<li>CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。</li>\n<li>CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。</li>\n<li>CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：&#x2F;run&#x2F;netns&#x2F;[nsname]）。</li>\n<li>CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。</li>\n<li>CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，”FOO&#x3D;BAR;ABC&#x3D;123”</li>\n<li>CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的’:’和Windows上的’；’。</li>\n</ul>\n<p>告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。</p>\n<p>对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：</p>\n<ul>\n<li><p>ADD</p>\n<ul>\n<li><p>将容器添加到网络中，或将新的配置修改应用到已有的集群当中。</p>\n</li>\n<li><p>一个CNI插件在收到ADD命令后，应该选择</p>\n<ul>\n<li><p>在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，</p>\n</li>\n<li><p>调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置</p>\n<p>如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DELETE</p>\n<ul>\n<li><p>将容器删除出网络，或将新的配置修改应用到已有的集群当中。</p>\n<p>功能与ADD 相对</p>\n</li>\n</ul>\n</li>\n<li><p>CHECK</p>\n<ul>\n<li>查找类型字段中指定的可执行文件，如果没找到返回错误</li>\n<li>当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"CNI-与插件\"><a href=\"#CNI-与插件\" class=\"headerlink\" title=\"CNI 与插件\"></a>CNI 与插件</h2><p>为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。</p>\n<p>一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP &#x2F; 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 <code>ADD</code>,<code>DELETE</code>。 </p>\n<p>CNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 <code>CNI_PATH</code>之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。</p>\n<p>如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。</p>\n<hr>\n<h1 id=\"CNI-配置文件样例\"><a href=\"#CNI-配置文件样例\" class=\"headerlink\" title=\"CNI 配置文件样例\"></a>CNI 配置文件样例</h1><blockquote>\n<p>参考<a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni&#x2F;SPEC.md at spec-v1.0.0 · containernetworking&#x2F;cni (github.com)</a> 的 Appendix: Examples</p>\n</blockquote>\n<p>借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Add-example\"><a href=\"#Add-example\" class=\"headerlink\" title=\"Add example\"></a>Add example</h3><p>The container runtime would perform the following steps for the <code>add</code> operation.</p>\n<ol>\n<li>Call the <code>bridge</code> plugin with the following JSON, <code>CNI_COMMAND=ADD</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">    &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">    &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">    &quot;ipam&quot;: &#123;</span><br><span class=\"line\">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">        &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">        &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">        &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin, as it delegates IPAM to the <code>host-local</code> plugin, would execute the <code>host-local</code> binary with the exact same input, <code>CNI_COMMAND=ADD</code>.</p>\n<p>The <code>host-local</code> plugin returns the following result:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Next, call the <code>tuning</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> is supplied, along with the <code>mac</code> capability argument. The request configuration passed is:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The plugin returns the following result. Note that the <strong>mac</strong> has changed.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Finally, call the <code>portmap</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> matches that returned by <code>tuning</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The <code>portmap</code> plugin outputs the exact same result as that returned by <code>bridge</code>, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).</p>\n<h3 id=\"Check-example\"><a href=\"#Check-example\" class=\"headerlink\" title=\"Check example\"></a>Check example</h3><p>Given the previous <em>Add</em>, the container runtime would perform the following steps for the <em>Check</em> action:</p>\n<ol>\n<li>First call the <code>bridge</code> plugin with the following request configuration, including the <code>prevResult</code> field containing the final JSON response from the <em>Add</em> operation, <strong>including the changed mac</strong>. <code>CNI_COMMAND=CHECK</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">  &quot;ipam&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dns&quot;: &#123;</span><br><span class=\"line\">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The <code>bridge</code> plugin, as it delegates IPAM, calls <code>host-local</code>, <code>CNI_COMMAND=CHECK</code>. It returns no error.</p>\n<p>Assuming the <code>bridge</code> plugin is satisfied, it produces no output on standard out and exits with a 0 return code.</p>\n<ol>\n<li>Next call the <code>tuning</code> plugin with the following request configuration:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Likewise, the <code>tuning</code> plugin exits indicating success.</p>\n<ol>\n<li>Finally, call <code>portmap</code> with the following request configuration:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Delete-example\"><a href=\"#Delete-example\" class=\"headerlink\" title=\"Delete example\"></a>Delete example</h3><p>Given the same network configuration JSON list, the container runtime would perform the following steps for the <em>Delete</em> action. Note that plugins are executed in reverse order from the <em>Add</em> and <em>Check</em> actions.</p>\n<ol>\n<li>First, call <code>portmap</code> with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Next, call the <code>tuning</code> plugin with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Finally, call <code>bridge</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">  &quot;ipam&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dns&quot;: &#123;</span><br><span class=\"line\">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin executes the <code>host-local</code> delegated plugin with <code>CNI_COMMAND=DEL</code> before returning.</p>\n<hr>\n<h2 id=\"相关仓库及文献\"><a href=\"#相关仓库及文献\" class=\"headerlink\" title=\"相关仓库及文献\"></a>相关仓库及文献</h2><p><a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni&#x2F;SPEC.md at spec-v1.0.0 · containernetworking&#x2F;cni (github.com)</a></p>\n<p><a href=\"https://lengrongfu.github.io/2022-05-11-k8s%E4%B9%8BCNI%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/\">Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)</a></p>\n<p><a href=\"https://www.redhat.com/sysadmin/cni-kubernetes\">A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)</a></p>\n<p><a href=\"https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli\">Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn</a></p>\n<p><a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/\">Network Plugins | Kubernetes</a></p>\n<p><a href=\"https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/\">Kubernetes CNI Explained (tigera.io)</a></p>\n","cover":false,"excerpt":"","more":"<h1 id=\"CNI-概述\"><a href=\"#CNI-概述\" class=\"headerlink\" title=\"CNI 概述\"></a>CNI 概述</h1><h2 id=\"什么是-CNI\"><a href=\"#什么是-CNI\" class=\"headerlink\" title=\"什么是 CNI\"></a>什么是 CNI</h2><blockquote>\n<p>CNI的全称是 Container Network Interface，它为<strong>容器提供了一种基于插件结构的标准化网络解决方案</strong>。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。<strong>CNI从网络服务里抽象出了一套标准接口</strong>，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。</p>\n</blockquote>\n<p>首先 CNI 是一套标准接口，它隶属于<a href=\"https://cncf.io/\">CNCF(Cloud Native Computing Foundation)</a>，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p>\n<p>其次 依据 CNI 的<a href=\"https://github.com/containernetworking/cni/blob/master/SPEC.md\">规范</a>，CNI 具有以下几点特征：</p>\n<ul>\n<li>CNI 需提供网络管理员<strong>定义网络配置的文件格式</strong></li>\n<li>CNI 需提供 Container Runtime（CRI） 调用功能的<strong>协议&#x2F;API</strong>。</li>\n<li>当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能</li>\n<li>CNI 需预留可调用其他插件的能力</li>\n<li>CNI 需规范统一返回给CRI 的数据格式</li>\n</ul>\n<p>依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：</p>\n<ul>\n<li>可执行文件<ul>\n<li>CNI 主进程</li>\n<li>IPAM 等</li>\n</ul>\n</li>\n<li>网络配置文件</li>\n</ul>\n<hr>\n<h2 id=\"CNI-的功能\"><a href=\"#CNI-的功能\" class=\"headerlink\" title=\"CNI 的功能\"></a>CNI 的功能</h2><p>CNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供<strong>基础的 Linux 网络联通服务</strong>，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后<strong>将IP 分配给接口</strong>，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。</p>\n<p>那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准</p>\n<hr>\n<h2 id=\"CNI-统一的网络配置文件\"><a href=\"#CNI-统一的网络配置文件\" class=\"headerlink\" title=\"CNI 统一的网络配置文件\"></a>CNI 统一的网络配置文件</h2><p>CNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。</p>\n<p>一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：</p>\n<ul>\n<li><code>cniVersion</code>: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此</li>\n<li><code>Name</code>: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。</li>\n<li><code>disableCheck</code>: 是否禁用检查网络，如果为true,则 <code>container runtime</code> 不会调用 Check 方法进行网络检查。</li>\n<li><code>plugin</code>: cni插件及其配置列表，可以配置多个插件。</li>\n</ul>\n<p>接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理</p>\n<ol>\n<li><p>必须配置的键值</p>\n<p><code>type</code> :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引</p>\n<p>至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能</p>\n</li>\n<li><p>可选键值，由 CRI 依据协议发送的 request 指定</p>\n<p><code>capabilities</code>:  如果 CNI_ARGS 中没有指定此项功能时候来补充的</p>\n</li>\n<li><p>预留键值，由 CRI 在执行时产生的</p>\n<ul>\n<li><code>runtimeConfig</code> :  比如 CNI 自己设置的 isGateway &#x3D;&#x3D; true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。</li>\n<li><code>args</code></li>\n<li>或者是任何以 <code>cni.dev/</code>开头的</li>\n</ul>\n</li>\n<li><p>可选键值,由容器网络管理员添加</p>\n<p><code>ipMasq</code>: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。</p>\n<p>当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。</p>\n<p><code>ipam</code>: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件</p>\n<blockquote>\n<p>例子1当中：</p>\n<ul>\n<li>type：指定所用IPAM插件的名称，在例子里，用的是host-local。</li>\n<li>subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为<code>10.15.10.0/24</code>，也就是目标网段为<code>10.15.10.0</code>，子网掩码为<code>255.255.255.0</code>。</li>\n<li>routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为<code>0.0.0.0/0</code>则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</li>\n<li>rangeStart：允许分配的IP地址范围的起始值</li>\n<li>rangeEnd：允许分配的IP地址范围的结束值</li>\n<li>gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>配置文件例子如下：</p>\n<p>例子1：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.4.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;isGateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipMasq&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.0/24&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span> <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeStart&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.100&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeEnd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.200&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>例子2：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"CNI-运行时协议\"><a href=\"#CNI-运行时协议\" class=\"headerlink\" title=\"CNI 运行时协议\"></a>CNI 运行时协议</h2><p>CNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。</p>\n<p>主要的协议参数定义如下：</p>\n<ul>\n<li>CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。</li>\n<li>CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。</li>\n<li>CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：&#x2F;run&#x2F;netns&#x2F;[nsname]）。</li>\n<li>CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。</li>\n<li>CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，”FOO&#x3D;BAR;ABC&#x3D;123”</li>\n<li>CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的’:’和Windows上的’；’。</li>\n</ul>\n<p>告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。</p>\n<p>对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：</p>\n<ul>\n<li><p>ADD</p>\n<ul>\n<li><p>将容器添加到网络中，或将新的配置修改应用到已有的集群当中。</p>\n</li>\n<li><p>一个CNI插件在收到ADD命令后，应该选择</p>\n<ul>\n<li><p>在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，</p>\n</li>\n<li><p>调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置</p>\n<p>如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DELETE</p>\n<ul>\n<li><p>将容器删除出网络，或将新的配置修改应用到已有的集群当中。</p>\n<p>功能与ADD 相对</p>\n</li>\n</ul>\n</li>\n<li><p>CHECK</p>\n<ul>\n<li>查找类型字段中指定的可执行文件，如果没找到返回错误</li>\n<li>当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"CNI-与插件\"><a href=\"#CNI-与插件\" class=\"headerlink\" title=\"CNI 与插件\"></a>CNI 与插件</h2><p>为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。</p>\n<p>一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP &#x2F; 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 <code>ADD</code>,<code>DELETE</code>。 </p>\n<p>CNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 <code>CNI_PATH</code>之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。</p>\n<p>如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。</p>\n<hr>\n<h1 id=\"CNI-配置文件样例\"><a href=\"#CNI-配置文件样例\" class=\"headerlink\" title=\"CNI 配置文件样例\"></a>CNI 配置文件样例</h1><blockquote>\n<p>参考<a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni&#x2F;SPEC.md at spec-v1.0.0 · containernetworking&#x2F;cni (github.com)</a> 的 Appendix: Examples</p>\n</blockquote>\n<p>借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Add-example\"><a href=\"#Add-example\" class=\"headerlink\" title=\"Add example\"></a>Add example</h3><p>The container runtime would perform the following steps for the <code>add</code> operation.</p>\n<ol>\n<li>Call the <code>bridge</code> plugin with the following JSON, <code>CNI_COMMAND=ADD</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">    &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">    &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">    &quot;ipam&quot;: &#123;</span><br><span class=\"line\">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">        &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">        &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">        &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin, as it delegates IPAM to the <code>host-local</code> plugin, would execute the <code>host-local</code> binary with the exact same input, <code>CNI_COMMAND=ADD</code>.</p>\n<p>The <code>host-local</code> plugin returns the following result:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Next, call the <code>tuning</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> is supplied, along with the <code>mac</code> capability argument. The request configuration passed is:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The plugin returns the following result. Note that the <strong>mac</strong> has changed.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Finally, call the <code>portmap</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> matches that returned by <code>tuning</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The <code>portmap</code> plugin outputs the exact same result as that returned by <code>bridge</code>, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).</p>\n<h3 id=\"Check-example\"><a href=\"#Check-example\" class=\"headerlink\" title=\"Check example\"></a>Check example</h3><p>Given the previous <em>Add</em>, the container runtime would perform the following steps for the <em>Check</em> action:</p>\n<ol>\n<li>First call the <code>bridge</code> plugin with the following request configuration, including the <code>prevResult</code> field containing the final JSON response from the <em>Add</em> operation, <strong>including the changed mac</strong>. <code>CNI_COMMAND=CHECK</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">  &quot;ipam&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dns&quot;: &#123;</span><br><span class=\"line\">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The <code>bridge</code> plugin, as it delegates IPAM, calls <code>host-local</code>, <code>CNI_COMMAND=CHECK</code>. It returns no error.</p>\n<p>Assuming the <code>bridge</code> plugin is satisfied, it produces no output on standard out and exits with a 0 return code.</p>\n<ol>\n<li>Next call the <code>tuning</code> plugin with the following request configuration:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Likewise, the <code>tuning</code> plugin exits indicating success.</p>\n<ol>\n<li>Finally, call <code>portmap</code> with the following request configuration:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Delete-example\"><a href=\"#Delete-example\" class=\"headerlink\" title=\"Delete example\"></a>Delete example</h3><p>Given the same network configuration JSON list, the container runtime would perform the following steps for the <em>Delete</em> action. Note that plugins are executed in reverse order from the <em>Add</em> and <em>Check</em> actions.</p>\n<ol>\n<li>First, call <code>portmap</code> with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Next, call the <code>tuning</code> plugin with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Finally, call <code>bridge</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">  &quot;ipam&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dns&quot;: &#123;</span><br><span class=\"line\">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin executes the <code>host-local</code> delegated plugin with <code>CNI_COMMAND=DEL</code> before returning.</p>\n<hr>\n<h2 id=\"相关仓库及文献\"><a href=\"#相关仓库及文献\" class=\"headerlink\" title=\"相关仓库及文献\"></a>相关仓库及文献</h2><p><a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni&#x2F;SPEC.md at spec-v1.0.0 · containernetworking&#x2F;cni (github.com)</a></p>\n<p><a href=\"https://lengrongfu.github.io/2022-05-11-k8s%E4%B9%8BCNI%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/\">Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)</a></p>\n<p><a href=\"https://www.redhat.com/sysadmin/cni-kubernetes\">A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)</a></p>\n<p><a href=\"https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli\">Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn</a></p>\n<p><a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/\">Network Plugins | Kubernetes</a></p>\n<p><a href=\"https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/\">Kubernetes CNI Explained (tigera.io)</a></p>\n"},{"title":"创建简单的CNI插件","date":"2024-04-11T09:16:50.000Z","catalog":true,"_content":"\n> 使用 Golang 实现一个简易的 CNI \n> 对于 CNI 的功能实现将按照循序渐进的方式来进行\n> 实现目标\n>\n> * 依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址\n> * 提供容器网络通信服务\n>\n> 实验的代码和脚本可以在 [IdeaMeshDyx/knetwork](https://github.com/IdeaMeshDyx/knetwork) 中找到\n\n##  设计简易的 CNI 工作逻辑\n\n由于 cni 提供的服务集中于节点的 L2/L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。\n\n依据上一篇[博客](https://ideameshdyx.github.io/2023/04/18/EdgeMesh/2023-ospp-fighting/CNI-Basic/)所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：\n\n1. kubelet 先创建 pause 容器创建对应的网络命名空间；\n2. cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；\n3. 当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；\n4. CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；\n\n\n* 当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。\n  * 当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接\n  * 当销毁容器的时候，删除为容器分配的所有网络资源\n* cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)\n  * cni 执行的命令和操作(cni必须要实现的核心可调用功能)\n    * ADD\n    * DELETE\n    * VERSION\n    * CHECK\n  * 容器ID(服务的容器对象ID)\n  * 节点容器所连接网络空间的路径\n  * 容器中需要创建的接口名称\n  * 目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是`/opt/cni/bin`)\n  * cni 配置文件的路径\n\n而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。\n比如 Docker 当中设置 `vim /usr/lib/systemd/system/docker.service` 中 `--bip=10.244.12.1/24 ` 如下：\n\n``` shell\n[Service]\nType=notify\n# the default is not to use systemd for cgroups because the delegate issues still\n# exists and systemd currently does not support the cgroup feature set required\n# for containers run by docker\nExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450\nExecReload=/bin/kill -s HUP $MAINPID\nTimeoutStartSec=0\nRestartSec=2\nRestart=always\n```\n\n\n## 代码实现\n\n\n### **Step1 : 创建 cni 主流程**\n\n首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。\n所以可以先得到一个最基本的 cni 主程序框架如下：\n\n``` golang\npackage main \n\nimport (\n    \"github.com/containernetworking/cni/pkg/skel\"\n    \"github.com/containernetworking/cni/pkg/version\"\n)\nfunc cmdAdd(args *skel.CmdArgs) error {\n    /**\n    TODO: add code about cmdAdd\n    */\n    // 测试是否 cni 接收到了传入的容器网络配置参数\n    fmt.Printf(\"interfance Name: %s\\n\", args.IfName)\n\t  fmt.Printf(\"Netns path: %s\\n\", args.Netns)\n\t  fmt.Printf(\"The config data: %s\\n\", args.StdinData)\n    return nil\n}\n\nfunc cmdDel(args *skel.CmdArgs) error {\n    /**\n    TODO: add code about cmdDel\n    */\n    return nil\n}\n\nfunc main(){\n    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)\n}\n\n```\n\n按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。\n\n传入的参数具体内容定义在 `pkg/skel/skel.go`:\n\n```golang\n// CmdArgs captures all the arguments passed in to the plugin\n// via both env vars and stdin\ntype CmdArgs struct {\n\tContainerID   string\n\tNetns         string\n\tIfName        string\n\tArgs          string\n\tPath          string\n\tNetnsOverride string\n\tStdinData     []byte\n}\n```\n\n当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list/watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。\n\n接下来为检验以上的功能逻辑通畅，创建以下 config 文件：\n\n``` yaml\n{\n\t\"name\": \"mynet\",\n\t\"BridgeName\": \"test\",\n\t\"IP\": \"192.0.2.1/24\"\n}\n```\n\n那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：\n\n``` shell\n\tgo build -o example .\n\techo \"Ready to call the cni program and create resources\"\n\tsudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example < config\n\techo \"The CNI has been called, see the following results\"\n```\n\n得到以下输出：\n\n``` shell\n[root@master knet]# ./run.sh\nReady to call the cni program and create resources\ninterfance Name: eth10\nnetns path: /var/run/netns/ns1\nthe config data: {\n        \"name\": \"mynet\",\n        \"BridgeName\": \"test\",\n        \"IP\": \"192.0.2.1/24\"\n}\nThe CNI has been called, see the following results\n```\n\n通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。\n\n\n### **step2: 实现 cmdAdd 功能**\n\n本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：\n\n1. 从配置中读取网桥信息。\n2. 获取我们想要使用的网桥名称。\n3. 如果系统中不存在该网桥，则创建它。\n\n由于 cni 的框架里面将配置内容以字节数组的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些字节数组的数据，数据格式需要兼容规范的各类对象。\n\n``` golang\n// 简单的网桥结构\ntype SimpleBridge struct {\n\tBridgeName string `json:\"bridgeName\"`\n\tIP         string `json:\"ip\"`\n}\n\n// 在cmdAdd中解析传入的参数内容\nfunc cmdAdd(args *skel.CmdArgs) error {\n\n}\n\n```\n\n当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能\n\n```golang\n/**\n1. 准备好我们想要的 netlink.Bridge 对象。\n2. 创建网桥对象\n3. 设置Linux网桥参数\n*/\nbr := &netlink.Bridge{\n\tLinkAttrs: netlink.LinkAttrs{\n\t\tName: sb.BridgeName,\n\t\tMTU:  1500,\n\t\t// Let kernel use default txqueuelen; leaving it unset\n\t\t// means 0, and a zero-length TX queue messes up FIFO\n\t\t// traffic shapers which use TX queue length as the\n\t\t// default packet limit\n\t\tTxQLen: -1,\n\t},\n}\n\nerr := netlink.LinkAdd(br)\nif err != nil && err != syscall.EEXIST {\n\treturn err\n}\n\nif err := netlink.LinkSetUp(br); err != nil {\n\treturn err\n}\n\n```\n\n> 当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 `github.com/containernetworking/cni/pkg/skel` 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。\n> [netlink](https://github.com/vishvananda/netlink)\n> [go-cni](https://github.com/containerd/go-cni/tree/main)\n> [intel-cni](https://github.com/containerd/go-cni/tree/main)\n> [sr-cni](https://github.com/containerd/go-cni/tree/main)\n\n到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。\n\n说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：\n\n1. 从我们之前创建的Bridge中获取Bridge对象\n2. 获取容器的命名空间\n3. 在容器上创建一个 veth，并将主机端 veth 移至主机 ns。\n4. 将主机端 veth 附加到 linux bridge 上\n\n在这个过程当中有一些地方需要注意：\n\n* 需要检验已创建的网络资源，避免冲突\n* 获取并处理容器的网络空间\n\n这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。\n\n这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。\n\n```golang\n// 获取本地的网络设备情况\nl, err := netlink.LinkByName(sb.BridgeName)\nif err != nil {\n    return fmt.Errorf(\"could not lookup %q: %v\", sb.BridgeName, err)\n}\n\n// 比较是否有冲突的问题\nnewBr, ok := l.(*netlink.Bridge)\nif !ok {\n    return fmt.Errorf(\"%q already exists but is not a bridge\", sb.BridgeName)\n}\n```\n\n而对于容器网络信息的获取，在之前的指令中也涉及到`CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1`,这部分信息可以通过传入的参数获取。\n\n```golang\nnetns, err := ns.GetNS(args.Netns)\nif err != nil {\n\treturn err\n}\n```\n\n接下来对于每一个 `NetNs`对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。\n\n``` golang\n// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]\nhostIface := &current.Interface{}\n\tvar handler = func(hostNS ns.NetNS) error {\n\t\thostVeth, _, err := ip.SetupVeth(args.IfName, 1500, hostNS)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostIface.Name = hostVeth.Name\n\t\treturn nil\n}\n\n// 为每一个容器调用 handler\nif err := netns.Do(handler); err != nil {\n\t\treturn err\n}\n\n// 获取所创建的 Bridge \nhostVeth, err := netlink.LinkByName(hostIface.Name)\n\tif err != nil {\n\t\treturn err\n}\n\n// 将 veth 附加到创建的网桥上\nif err := netlink.LinkSetMaster(hostVeth, newBr); err != nil {\n\t\treturn err\n}\n```\n\n在上述过程当中，我们通过 `hostIface.Name` 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 `netlink.LinkByName` 函数从接口名称中获取链接对象, 然后调用 `netlink.LinkSetMaster` 函数将链接连接到网桥上。\n\n> 在操作过程中有一个非常重要的关注点： **确保操作系统不会在命名空间的操作中切换线程**\n> 可以参考 [steps-in-context-switching](https://stackoverflow.com/questions/7439608/steps-in-context-switching) \n>\n> 命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。\n>\n> 如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。\n>\n> 因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。\n\n所以我们使用以下方式限制,具体的使用手册是：\n[benefits-of-runtime-lockosthread-in-golang](https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang)\n[go-pkg-runtime](https://pkg.go.dev/runtime)\n\n```golang\nfunc init() {\n        // this ensures that main runs only on main thread (thread group leader).\n        // since namespace ops (unshare, setns) are done for a single thread, we\n        // must ensure that the goroutine does not jump from OS thread to thread\n        runtime.LockOSThread()\n}\n```\n\n通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。\n\nIP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。\n这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。\n\n不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 \n\n依据上述的逻辑，我们可以得到接下来的代码实现流程：\n\n1. 依据配置中生成一个IP对象。\n2. 在目标网络命名空间中调用netlink.AddrAdd。\n\n那么接着看看 `netlink`  当中是如何实现他对于地址分配的呢？\n\n```golang\n// 位于 addr.go\n// Addr represents an IP address from netlink. Netlink ip addresses\n// include a mask, so it stores the address as a net.IPNet.\ntype Addr struct {\n\t*net.IPNet\n\tLabel       string\n\tFlags       int\n\tScope       int\n\tPeer        *net.IPNet\n\tBroadcast   net.IP\n\tPreferedLft int\n\tValidLft    int\n\tLinkIndex   int\n}\n\n// 位于 addr_linux.go\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\nfunc AddrAdd(link Link, addr *Addr) error {\n\treturn pkgHandle.AddrAdd(link, addr)\n}\n\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\nfunc (h *Handle) AddrAdd(link Link, addr *Addr) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\treturn h.addrHandle(link, addr, req)\n}\n\n```\n\n我们使用 golang 提供的 `net` 包来生成 `net.IPNet` 类型和它的CIDR形式（IP地址和Mask），然后通过 `net.ParseCIDR` 来解析配置文件中获取的IP字符串并返回一个 `net.IPNet` 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 `net.ParseCIDR` 得到的 `net.IPNet` 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。\n\n```golang\nvar handler = func(hostNS ns.NetNS) error {\n    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, 1500, hostNS)\n    if err != nil {\n        return err\n    }\n    hostIface.Name = hostVeth.Name\n    // 在这里创建 IP  地址对象\n    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)\n    if err != nil {\n        return err\n    }\n\n    link, err := netlink.LinkByName(containerVeth.Name)\n    if err != nil {\n        return err\n    }\n    // 创建 IP 地址\n    ipv4Net.IP = ipv4Addr\n\n    addr := &netlink.Addr{IPNet: ipv4Net, Label: \"\"}\n    if err = netlink.AddrAdd(link, addr); err != nil {\n        return err\n    }\n    return nil\n}\n```\n\n到这里，一个基础且完整的 `cmdAdd` 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能\n\n```shell\n# 删除先前创建的资源\nsudo ip netns del ns1\nsudo ifconfig test down\nsudo brctl delbr test\n\n# 重新创建 ns1 来模拟容器\nsudo ip netns add ns1\ngo build -o example .\n\n# 执行 cni 来生成地址\necho \"Ready to call the cni to create ip for ns1\"\nsudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example < config\necho \"The CNI has been called, see the following results\"\necho \"The bridge and the veth has been attatch to\"\nsudo brctl show test\necho \"The interface in the netns\"\nsudo ip netns exec ns1 ifconfig -a\n```\n\n执行的结果如下：\n\n``` shell\n[root@master knet]# ./run.sh \nCannot remove namespace file \"/var/run/netns/ns1\": No such file or directory\ntest: ERROR while getting interface flags: No such device\nbridge test doesn't exist; can't delete it\nReady to call the cni to create ip for ns1\n{test 192.0.2.15/24}\nThe CNI has been called, see the following results\nThe bridge and the veth has been attatch to\nbridge name     bridge id               STP enabled     interfaces\ntest            8000.b6e6090625de       no              veth2a9d8a3d\nThe interface in the netns\neth10: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255\n        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20<link>\n        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)\n        RX packets 1  bytes 90 (90.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1  bytes 90 (90.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=8<LOOPBACK>  mtu 65536\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。\n\n```shell\n[root@master knet]# sudo ifconfig test 192.0.2.1\n[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1\nPING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.\n64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms\n64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms\n64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms\n64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms\n^C\n--- 192.0.2.1 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, ti\n```\n\n\n> 主要参考文章：\n> [Container Network Interface](https://www.hwchiu.com/introduce-cni-iii.html)\n> [Create your CNI ](https://morven.life/posts/create-your-own-cni-with-golang/)","source":"_posts/2024/04/create-cni.md","raw":"---\ntitle: 创建简单的CNI插件\ndate: 2024-04-11 17:16:50\ntags: ospp, cni, Linux\ncategories: EdgeMesh\ncatalog: true\n---\n\n> 使用 Golang 实现一个简易的 CNI \n> 对于 CNI 的功能实现将按照循序渐进的方式来进行\n> 实现目标\n>\n> * 依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址\n> * 提供容器网络通信服务\n>\n> 实验的代码和脚本可以在 [IdeaMeshDyx/knetwork](https://github.com/IdeaMeshDyx/knetwork) 中找到\n\n##  设计简易的 CNI 工作逻辑\n\n由于 cni 提供的服务集中于节点的 L2/L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。\n\n依据上一篇[博客](https://ideameshdyx.github.io/2023/04/18/EdgeMesh/2023-ospp-fighting/CNI-Basic/)所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：\n\n1. kubelet 先创建 pause 容器创建对应的网络命名空间；\n2. cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；\n3. 当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；\n4. CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；\n\n\n* 当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。\n  * 当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接\n  * 当销毁容器的时候，删除为容器分配的所有网络资源\n* cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)\n  * cni 执行的命令和操作(cni必须要实现的核心可调用功能)\n    * ADD\n    * DELETE\n    * VERSION\n    * CHECK\n  * 容器ID(服务的容器对象ID)\n  * 节点容器所连接网络空间的路径\n  * 容器中需要创建的接口名称\n  * 目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是`/opt/cni/bin`)\n  * cni 配置文件的路径\n\n而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。\n比如 Docker 当中设置 `vim /usr/lib/systemd/system/docker.service` 中 `--bip=10.244.12.1/24 ` 如下：\n\n``` shell\n[Service]\nType=notify\n# the default is not to use systemd for cgroups because the delegate issues still\n# exists and systemd currently does not support the cgroup feature set required\n# for containers run by docker\nExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450\nExecReload=/bin/kill -s HUP $MAINPID\nTimeoutStartSec=0\nRestartSec=2\nRestart=always\n```\n\n\n## 代码实现\n\n\n### **Step1 : 创建 cni 主流程**\n\n首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。\n所以可以先得到一个最基本的 cni 主程序框架如下：\n\n``` golang\npackage main \n\nimport (\n    \"github.com/containernetworking/cni/pkg/skel\"\n    \"github.com/containernetworking/cni/pkg/version\"\n)\nfunc cmdAdd(args *skel.CmdArgs) error {\n    /**\n    TODO: add code about cmdAdd\n    */\n    // 测试是否 cni 接收到了传入的容器网络配置参数\n    fmt.Printf(\"interfance Name: %s\\n\", args.IfName)\n\t  fmt.Printf(\"Netns path: %s\\n\", args.Netns)\n\t  fmt.Printf(\"The config data: %s\\n\", args.StdinData)\n    return nil\n}\n\nfunc cmdDel(args *skel.CmdArgs) error {\n    /**\n    TODO: add code about cmdDel\n    */\n    return nil\n}\n\nfunc main(){\n    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)\n}\n\n```\n\n按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。\n\n传入的参数具体内容定义在 `pkg/skel/skel.go`:\n\n```golang\n// CmdArgs captures all the arguments passed in to the plugin\n// via both env vars and stdin\ntype CmdArgs struct {\n\tContainerID   string\n\tNetns         string\n\tIfName        string\n\tArgs          string\n\tPath          string\n\tNetnsOverride string\n\tStdinData     []byte\n}\n```\n\n当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list/watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。\n\n接下来为检验以上的功能逻辑通畅，创建以下 config 文件：\n\n``` yaml\n{\n\t\"name\": \"mynet\",\n\t\"BridgeName\": \"test\",\n\t\"IP\": \"192.0.2.1/24\"\n}\n```\n\n那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：\n\n``` shell\n\tgo build -o example .\n\techo \"Ready to call the cni program and create resources\"\n\tsudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example < config\n\techo \"The CNI has been called, see the following results\"\n```\n\n得到以下输出：\n\n``` shell\n[root@master knet]# ./run.sh\nReady to call the cni program and create resources\ninterfance Name: eth10\nnetns path: /var/run/netns/ns1\nthe config data: {\n        \"name\": \"mynet\",\n        \"BridgeName\": \"test\",\n        \"IP\": \"192.0.2.1/24\"\n}\nThe CNI has been called, see the following results\n```\n\n通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。\n\n\n### **step2: 实现 cmdAdd 功能**\n\n本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：\n\n1. 从配置中读取网桥信息。\n2. 获取我们想要使用的网桥名称。\n3. 如果系统中不存在该网桥，则创建它。\n\n由于 cni 的框架里面将配置内容以字节数组的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些字节数组的数据，数据格式需要兼容规范的各类对象。\n\n``` golang\n// 简单的网桥结构\ntype SimpleBridge struct {\n\tBridgeName string `json:\"bridgeName\"`\n\tIP         string `json:\"ip\"`\n}\n\n// 在cmdAdd中解析传入的参数内容\nfunc cmdAdd(args *skel.CmdArgs) error {\n\n}\n\n```\n\n当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能\n\n```golang\n/**\n1. 准备好我们想要的 netlink.Bridge 对象。\n2. 创建网桥对象\n3. 设置Linux网桥参数\n*/\nbr := &netlink.Bridge{\n\tLinkAttrs: netlink.LinkAttrs{\n\t\tName: sb.BridgeName,\n\t\tMTU:  1500,\n\t\t// Let kernel use default txqueuelen; leaving it unset\n\t\t// means 0, and a zero-length TX queue messes up FIFO\n\t\t// traffic shapers which use TX queue length as the\n\t\t// default packet limit\n\t\tTxQLen: -1,\n\t},\n}\n\nerr := netlink.LinkAdd(br)\nif err != nil && err != syscall.EEXIST {\n\treturn err\n}\n\nif err := netlink.LinkSetUp(br); err != nil {\n\treturn err\n}\n\n```\n\n> 当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 `github.com/containernetworking/cni/pkg/skel` 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。\n> [netlink](https://github.com/vishvananda/netlink)\n> [go-cni](https://github.com/containerd/go-cni/tree/main)\n> [intel-cni](https://github.com/containerd/go-cni/tree/main)\n> [sr-cni](https://github.com/containerd/go-cni/tree/main)\n\n到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。\n\n说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：\n\n1. 从我们之前创建的Bridge中获取Bridge对象\n2. 获取容器的命名空间\n3. 在容器上创建一个 veth，并将主机端 veth 移至主机 ns。\n4. 将主机端 veth 附加到 linux bridge 上\n\n在这个过程当中有一些地方需要注意：\n\n* 需要检验已创建的网络资源，避免冲突\n* 获取并处理容器的网络空间\n\n这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。\n\n这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。\n\n```golang\n// 获取本地的网络设备情况\nl, err := netlink.LinkByName(sb.BridgeName)\nif err != nil {\n    return fmt.Errorf(\"could not lookup %q: %v\", sb.BridgeName, err)\n}\n\n// 比较是否有冲突的问题\nnewBr, ok := l.(*netlink.Bridge)\nif !ok {\n    return fmt.Errorf(\"%q already exists but is not a bridge\", sb.BridgeName)\n}\n```\n\n而对于容器网络信息的获取，在之前的指令中也涉及到`CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1`,这部分信息可以通过传入的参数获取。\n\n```golang\nnetns, err := ns.GetNS(args.Netns)\nif err != nil {\n\treturn err\n}\n```\n\n接下来对于每一个 `NetNs`对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。\n\n``` golang\n// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]\nhostIface := &current.Interface{}\n\tvar handler = func(hostNS ns.NetNS) error {\n\t\thostVeth, _, err := ip.SetupVeth(args.IfName, 1500, hostNS)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostIface.Name = hostVeth.Name\n\t\treturn nil\n}\n\n// 为每一个容器调用 handler\nif err := netns.Do(handler); err != nil {\n\t\treturn err\n}\n\n// 获取所创建的 Bridge \nhostVeth, err := netlink.LinkByName(hostIface.Name)\n\tif err != nil {\n\t\treturn err\n}\n\n// 将 veth 附加到创建的网桥上\nif err := netlink.LinkSetMaster(hostVeth, newBr); err != nil {\n\t\treturn err\n}\n```\n\n在上述过程当中，我们通过 `hostIface.Name` 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 `netlink.LinkByName` 函数从接口名称中获取链接对象, 然后调用 `netlink.LinkSetMaster` 函数将链接连接到网桥上。\n\n> 在操作过程中有一个非常重要的关注点： **确保操作系统不会在命名空间的操作中切换线程**\n> 可以参考 [steps-in-context-switching](https://stackoverflow.com/questions/7439608/steps-in-context-switching) \n>\n> 命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。\n>\n> 如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。\n>\n> 因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。\n\n所以我们使用以下方式限制,具体的使用手册是：\n[benefits-of-runtime-lockosthread-in-golang](https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang)\n[go-pkg-runtime](https://pkg.go.dev/runtime)\n\n```golang\nfunc init() {\n        // this ensures that main runs only on main thread (thread group leader).\n        // since namespace ops (unshare, setns) are done for a single thread, we\n        // must ensure that the goroutine does not jump from OS thread to thread\n        runtime.LockOSThread()\n}\n```\n\n通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。\n\nIP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。\n这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。\n\n不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 \n\n依据上述的逻辑，我们可以得到接下来的代码实现流程：\n\n1. 依据配置中生成一个IP对象。\n2. 在目标网络命名空间中调用netlink.AddrAdd。\n\n那么接着看看 `netlink`  当中是如何实现他对于地址分配的呢？\n\n```golang\n// 位于 addr.go\n// Addr represents an IP address from netlink. Netlink ip addresses\n// include a mask, so it stores the address as a net.IPNet.\ntype Addr struct {\n\t*net.IPNet\n\tLabel       string\n\tFlags       int\n\tScope       int\n\tPeer        *net.IPNet\n\tBroadcast   net.IP\n\tPreferedLft int\n\tValidLft    int\n\tLinkIndex   int\n}\n\n// 位于 addr_linux.go\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\nfunc AddrAdd(link Link, addr *Addr) error {\n\treturn pkgHandle.AddrAdd(link, addr)\n}\n\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\nfunc (h *Handle) AddrAdd(link Link, addr *Addr) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\treturn h.addrHandle(link, addr, req)\n}\n\n```\n\n我们使用 golang 提供的 `net` 包来生成 `net.IPNet` 类型和它的CIDR形式（IP地址和Mask），然后通过 `net.ParseCIDR` 来解析配置文件中获取的IP字符串并返回一个 `net.IPNet` 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 `net.ParseCIDR` 得到的 `net.IPNet` 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。\n\n```golang\nvar handler = func(hostNS ns.NetNS) error {\n    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, 1500, hostNS)\n    if err != nil {\n        return err\n    }\n    hostIface.Name = hostVeth.Name\n    // 在这里创建 IP  地址对象\n    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)\n    if err != nil {\n        return err\n    }\n\n    link, err := netlink.LinkByName(containerVeth.Name)\n    if err != nil {\n        return err\n    }\n    // 创建 IP 地址\n    ipv4Net.IP = ipv4Addr\n\n    addr := &netlink.Addr{IPNet: ipv4Net, Label: \"\"}\n    if err = netlink.AddrAdd(link, addr); err != nil {\n        return err\n    }\n    return nil\n}\n```\n\n到这里，一个基础且完整的 `cmdAdd` 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能\n\n```shell\n# 删除先前创建的资源\nsudo ip netns del ns1\nsudo ifconfig test down\nsudo brctl delbr test\n\n# 重新创建 ns1 来模拟容器\nsudo ip netns add ns1\ngo build -o example .\n\n# 执行 cni 来生成地址\necho \"Ready to call the cni to create ip for ns1\"\nsudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example < config\necho \"The CNI has been called, see the following results\"\necho \"The bridge and the veth has been attatch to\"\nsudo brctl show test\necho \"The interface in the netns\"\nsudo ip netns exec ns1 ifconfig -a\n```\n\n执行的结果如下：\n\n``` shell\n[root@master knet]# ./run.sh \nCannot remove namespace file \"/var/run/netns/ns1\": No such file or directory\ntest: ERROR while getting interface flags: No such device\nbridge test doesn't exist; can't delete it\nReady to call the cni to create ip for ns1\n{test 192.0.2.15/24}\nThe CNI has been called, see the following results\nThe bridge and the veth has been attatch to\nbridge name     bridge id               STP enabled     interfaces\ntest            8000.b6e6090625de       no              veth2a9d8a3d\nThe interface in the netns\neth10: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255\n        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20<link>\n        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)\n        RX packets 1  bytes 90 (90.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1  bytes 90 (90.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=8<LOOPBACK>  mtu 65536\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。\n\n```shell\n[root@master knet]# sudo ifconfig test 192.0.2.1\n[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1\nPING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.\n64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms\n64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms\n64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms\n64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms\n^C\n--- 192.0.2.1 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, ti\n```\n\n\n> 主要参考文章：\n> [Container Network Interface](https://www.hwchiu.com/introduce-cni-iii.html)\n> [Create your CNI ](https://morven.life/posts/create-your-own-cni-with-golang/)","slug":"create-cni","published":1,"updated":"2024-04-11T14:20:41.807Z","_id":"cluv14vff000452pegtp99u7a","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>使用 Golang 实现一个简易的 CNI<br>对于 CNI 的功能实现将按照循序渐进的方式来进行<br>实现目标</p>\n<ul>\n<li>依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址</li>\n<li>提供容器网络通信服务</li>\n</ul>\n<p>实验的代码和脚本可以在 <a href=\"https://github.com/IdeaMeshDyx/knetwork\">IdeaMeshDyx&#x2F;knetwork</a> 中找到</p>\n</blockquote>\n<h2 id=\"设计简易的-CNI-工作逻辑\"><a href=\"#设计简易的-CNI-工作逻辑\" class=\"headerlink\" title=\"设计简易的 CNI 工作逻辑\"></a>设计简易的 CNI 工作逻辑</h2><p>由于 cni 提供的服务集中于节点的 L2&#x2F;L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。</p>\n<p>依据上一篇<a href=\"https://ideameshdyx.github.io/2023/04/18/EdgeMesh/2023-ospp-fighting/CNI-Basic/\">博客</a>所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：</p>\n<ol>\n<li>kubelet 先创建 pause 容器创建对应的网络命名空间；</li>\n<li>cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；</li>\n<li>当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；</li>\n<li>CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；</li>\n</ol>\n<ul>\n<li>当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。<ul>\n<li>当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接</li>\n<li>当销毁容器的时候，删除为容器分配的所有网络资源</li>\n</ul>\n</li>\n<li>cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)<ul>\n<li>cni 执行的命令和操作(cni必须要实现的核心可调用功能)<ul>\n<li>ADD</li>\n<li>DELETE</li>\n<li>VERSION</li>\n<li>CHECK</li>\n</ul>\n</li>\n<li>容器ID(服务的容器对象ID)</li>\n<li>节点容器所连接网络空间的路径</li>\n<li>容器中需要创建的接口名称</li>\n<li>目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是<code>/opt/cni/bin</code>)</li>\n<li>cni 配置文件的路径</li>\n</ul>\n</li>\n</ul>\n<p>而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。<br>比如 Docker 当中设置 <code>vim /usr/lib/systemd/system/docker.service</code> 中 <code>--bip=10.244.12.1/24 </code> 如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Service]</span><br><span class=\"line\">Type=notify</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">the default is not to use systemd <span class=\"keyword\">for</span> cgroups because the delegate issues still</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">exists and systemd currently does not support the cgroup feature <span class=\"built_in\">set</span> required</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span> containers run by docker</span></span><br><span class=\"line\">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450</span><br><span class=\"line\">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class=\"line\">TimeoutStartSec=0</span><br><span class=\"line\">RestartSec=2</span><br><span class=\"line\">Restart=always</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"Step1-创建-cni-主流程\"><a href=\"#Step1-创建-cni-主流程\" class=\"headerlink\" title=\"Step1 : 创建 cni 主流程\"></a><strong>Step1 : 创建 cni 主流程</strong></h3><p>首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。<br>所以可以先得到一个最基本的 cni 主程序框架如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/containernetworking/cni/pkg/skel&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/containernetworking/cni/pkg/version&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdAdd</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">TODO:</span> add code about cmdAdd</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 测试是否 cni 接收到了传入的容器网络配置参数</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;interfance Name: %s\\n&quot;</span>, args.IfName)</span><br><span class=\"line\">\t  fmt.Printf(<span class=\"string\">&quot;Netns path: %s\\n&quot;</span>, args.Netns)</span><br><span class=\"line\">\t  fmt.Printf(<span class=\"string\">&quot;The config data: %s\\n&quot;</span>, args.StdinData)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdDel</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">TODO:</span> add code about cmdDel</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。</p>\n<p>传入的参数具体内容定义在 <code>pkg/skel/skel.go</code>:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CmdArgs captures all the arguments passed in to the plugin</span></span><br><span class=\"line\"><span class=\"comment\">// via both env vars and stdin</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> CmdArgs <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tContainerID   <span class=\"type\">string</span></span><br><span class=\"line\">\tNetns         <span class=\"type\">string</span></span><br><span class=\"line\">\tIfName        <span class=\"type\">string</span></span><br><span class=\"line\">\tArgs          <span class=\"type\">string</span></span><br><span class=\"line\">\tPath          <span class=\"type\">string</span></span><br><span class=\"line\">\tNetnsOverride <span class=\"type\">string</span></span><br><span class=\"line\">\tStdinData     []<span class=\"type\">byte</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list&#x2F;watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。</p>\n<p>接下来为检验以上的功能逻辑通畅，创建以下 config 文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;mynet&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;BridgeName&quot;:</span> <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;IP&quot;:</span> <span class=\"string\">&quot;192.0.2.1/24&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build -o example .</span><br><span class=\"line\">echo &quot;Ready to call the cni program and create resources&quot;</span><br><span class=\"line\">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class=\"line\">echo &quot;The CNI has been called, see the following results&quot;</span><br></pre></td></tr></table></figure>\n\n<p>得到以下输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# ./run.sh</span><br><span class=\"line\">Ready to call the cni program and create resources</span><br><span class=\"line\">interfance Name: eth10</span><br><span class=\"line\">netns path: /var/run/netns/ns1</span><br><span class=\"line\">the config data: &#123;</span><br><span class=\"line\">        &quot;name&quot;: &quot;mynet&quot;,</span><br><span class=\"line\">        &quot;BridgeName&quot;: &quot;test&quot;,</span><br><span class=\"line\">        &quot;IP&quot;: &quot;192.0.2.1/24&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">The CNI has been called, see the following results</span><br></pre></td></tr></table></figure>\n\n<p>通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。</p>\n<h3 id=\"step2-实现-cmdAdd-功能\"><a href=\"#step2-实现-cmdAdd-功能\" class=\"headerlink\" title=\"step2: 实现 cmdAdd 功能\"></a><strong>step2: 实现 cmdAdd 功能</strong></h3><p>本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：</p>\n<ol>\n<li>从配置中读取网桥信息。</li>\n<li>获取我们想要使用的网桥名称。</li>\n<li>如果系统中不存在该网桥，则创建它。</li>\n</ol>\n<p>由于 cni 的框架里面将配置内容以字节数组的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些字节数组的数据，数据格式需要兼容规范的各类对象。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单的网桥结构</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SimpleBridge <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tBridgeName <span class=\"type\">string</span> <span class=\"string\">`json:&quot;bridgeName&quot;`</span></span><br><span class=\"line\">\tIP         <span class=\"type\">string</span> <span class=\"string\">`json:&quot;ip&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在cmdAdd中解析传入的参数内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdAdd</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">1. 准备好我们想要的 netlink.Bridge 对象。</span></span><br><span class=\"line\"><span class=\"comment\">2. 创建网桥对象</span></span><br><span class=\"line\"><span class=\"comment\">3. 设置Linux网桥参数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">br := &amp;netlink.Bridge&#123;</span><br><span class=\"line\">\tLinkAttrs: netlink.LinkAttrs&#123;</span><br><span class=\"line\">\t\tName: sb.BridgeName,</span><br><span class=\"line\">\t\tMTU:  <span class=\"number\">1500</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// Let kernel use default txqueuelen; leaving it unset</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// means 0, and a zero-length TX queue messes up FIFO</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// traffic shapers which use TX queue length as the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// default packet limit</span></span><br><span class=\"line\">\t\tTxQLen: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">err := netlink.LinkAdd(br)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; err != syscall.EEXIST &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netlink.LinkSetUp(br); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 <code>github.com/containernetworking/cni/pkg/skel</code> 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。<br><a href=\"https://github.com/vishvananda/netlink\">netlink</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">go-cni</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">intel-cni</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">sr-cni</a></p>\n</blockquote>\n<p>到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。</p>\n<p>说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：</p>\n<ol>\n<li>从我们之前创建的Bridge中获取Bridge对象</li>\n<li>获取容器的命名空间</li>\n<li>在容器上创建一个 veth，并将主机端 veth 移至主机 ns。</li>\n<li>将主机端 veth 附加到 linux bridge 上</li>\n</ol>\n<p>在这个过程当中有一些地方需要注意：</p>\n<ul>\n<li>需要检验已创建的网络资源，避免冲突</li>\n<li>获取并处理容器的网络空间</li>\n</ul>\n<p>这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。</p>\n<p>这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取本地的网络设备情况</span></span><br><span class=\"line\">l, err := netlink.LinkByName(sb.BridgeName)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;could not lookup %q: %v&quot;</span>, sb.BridgeName, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较是否有冲突的问题</span></span><br><span class=\"line\">newBr, ok := l.(*netlink.Bridge)</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%q already exists but is not a bridge&quot;</span>, sb.BridgeName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而对于容器网络信息的获取，在之前的指令中也涉及到<code>CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1</code>,这部分信息可以通过传入的参数获取。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netns, err := ns.GetNS(args.Netns)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来对于每一个 <code>NetNs</code>对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]</span></span><br><span class=\"line\">hostIface := &amp;current.Interface&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hostNS ns.NetNS)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\thostVeth, _, err := ip.SetupVeth(args.IfName, <span class=\"number\">1500</span>, hostNS)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thostIface.Name = hostVeth.Name</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为每一个容器调用 handler</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netns.Do(handler); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取所创建的 Bridge </span></span><br><span class=\"line\">hostVeth, err := netlink.LinkByName(hostIface.Name)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 veth 附加到创建的网桥上</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netlink.LinkSetMaster(hostVeth, newBr); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述过程当中，我们通过 <code>hostIface.Name</code> 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 <code>netlink.LinkByName</code> 函数从接口名称中获取链接对象, 然后调用 <code>netlink.LinkSetMaster</code> 函数将链接连接到网桥上。</p>\n<blockquote>\n<p>在操作过程中有一个非常重要的关注点： <strong>确保操作系统不会在命名空间的操作中切换线程</strong><br>可以参考 <a href=\"https://stackoverflow.com/questions/7439608/steps-in-context-switching\">steps-in-context-switching</a> </p>\n<p>命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。</p>\n<p>如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。</p>\n<p>因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。</p>\n</blockquote>\n<p>所以我们使用以下方式限制,具体的使用手册是：<br><a href=\"https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang\">benefits-of-runtime-lockosthread-in-golang</a><br><a href=\"https://pkg.go.dev/runtime\">go-pkg-runtime</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// this ensures that main runs only on main thread (thread group leader).</span></span><br><span class=\"line\">        <span class=\"comment\">// since namespace ops (unshare, setns) are done for a single thread, we</span></span><br><span class=\"line\">        <span class=\"comment\">// must ensure that the goroutine does not jump from OS thread to thread</span></span><br><span class=\"line\">        runtime.LockOSThread()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。</p>\n<p>IP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。<br>这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。</p>\n<p>不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 </p>\n<p>依据上述的逻辑，我们可以得到接下来的代码实现流程：</p>\n<ol>\n<li>依据配置中生成一个IP对象。</li>\n<li>在目标网络命名空间中调用netlink.AddrAdd。</li>\n</ol>\n<p>那么接着看看 <code>netlink</code>  当中是如何实现他对于地址分配的呢？</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 位于 addr.go</span></span><br><span class=\"line\"><span class=\"comment\">// Addr represents an IP address from netlink. Netlink ip addresses</span></span><br><span class=\"line\"><span class=\"comment\">// include a mask, so it stores the address as a net.IPNet.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Addr <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*net.IPNet</span><br><span class=\"line\">\tLabel       <span class=\"type\">string</span></span><br><span class=\"line\">\tFlags       <span class=\"type\">int</span></span><br><span class=\"line\">\tScope       <span class=\"type\">int</span></span><br><span class=\"line\">\tPeer        *net.IPNet</span><br><span class=\"line\">\tBroadcast   net.IP</span><br><span class=\"line\">\tPreferedLft <span class=\"type\">int</span></span><br><span class=\"line\">\tValidLft    <span class=\"type\">int</span></span><br><span class=\"line\">\tLinkIndex   <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 位于 addr_linux.go</span></span><br><span class=\"line\"><span class=\"comment\">// AddrAdd will add an IP address to a link device.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class=\"line\"><span class=\"comment\">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AddrAdd</span><span class=\"params\">(link Link, addr *Addr)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pkgHandle.AddrAdd(link, addr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AddrAdd will add an IP address to a link device.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class=\"line\"><span class=\"comment\">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Handle)</span></span> AddrAdd(link Link, addr *Addr) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.addrHandle(link, addr, req)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们使用 golang 提供的 <code>net</code> 包来生成 <code>net.IPNet</code> 类型和它的CIDR形式（IP地址和Mask），然后通过 <code>net.ParseCIDR</code> 来解析配置文件中获取的IP字符串并返回一个 <code>net.IPNet</code> 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 <code>net.ParseCIDR</code> 得到的 <code>net.IPNet</code> 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hostNS ns.NetNS)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, <span class=\"number\">1500</span>, hostNS)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hostIface.Name = hostVeth.Name</span><br><span class=\"line\">    <span class=\"comment\">// 在这里创建 IP  地址对象</span></span><br><span class=\"line\">    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    link, err := netlink.LinkByName(containerVeth.Name)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 IP 地址</span></span><br><span class=\"line\">    ipv4Net.IP = ipv4Addr</span><br><span class=\"line\"></span><br><span class=\"line\">    addr := &amp;netlink.Addr&#123;IPNet: ipv4Net, Label: <span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err = netlink.AddrAdd(link, addr); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里，一个基础且完整的 <code>cmdAdd</code> 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除先前创建的资源</span></span><br><span class=\"line\">sudo ip netns del ns1</span><br><span class=\"line\">sudo ifconfig test down</span><br><span class=\"line\">sudo brctl delbr test</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重新创建 ns1 来模拟容器</span></span><br><span class=\"line\">sudo ip netns add ns1</span><br><span class=\"line\">go build -o example .</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">执行 cni 来生成地址</span></span><br><span class=\"line\">echo &quot;Ready to call the cni to create ip for ns1&quot;</span><br><span class=\"line\">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class=\"line\">echo &quot;The CNI has been called, see the following results&quot;</span><br><span class=\"line\">echo &quot;The bridge and the veth has been attatch to&quot;</span><br><span class=\"line\">sudo brctl show test</span><br><span class=\"line\">echo &quot;The interface in the netns&quot;</span><br><span class=\"line\">sudo ip netns exec ns1 ifconfig -a</span><br></pre></td></tr></table></figure>\n\n<p>执行的结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# ./run.sh </span><br><span class=\"line\">Cannot remove namespace file &quot;/var/run/netns/ns1&quot;: No such file or directory</span><br><span class=\"line\">test: ERROR while getting interface flags: No such device</span><br><span class=\"line\">bridge test doesn&#x27;t exist; can&#x27;t delete it</span><br><span class=\"line\">Ready to call the cni to create ip for ns1</span><br><span class=\"line\">&#123;test 192.0.2.15/24&#125;</span><br><span class=\"line\">The CNI has been called, see the following results</span><br><span class=\"line\">The bridge and the veth has been attatch to</span><br><span class=\"line\">bridge name     bridge id               STP enabled     interfaces</span><br><span class=\"line\">test            8000.b6e6090625de       no              veth2a9d8a3d</span><br><span class=\"line\">The interface in the netns</span><br><span class=\"line\">eth10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255</span><br><span class=\"line\">        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)</span><br><span class=\"line\">        RX packets 1  bytes 90 (90.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 1  bytes 90 (90.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags=8&lt;LOOPBACK&gt;  mtu 65536</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>\n\n<p>可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# sudo ifconfig test 192.0.2.1</span><br><span class=\"line\">[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1</span><br><span class=\"line\">PING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms</span><br><span class=\"line\">^C</span><br><span class=\"line\">--- 192.0.2.1 ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 received, 0% packet loss, ti</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>主要参考文章：<br><a href=\"https://www.hwchiu.com/introduce-cni-iii.html\">Container Network Interface</a><br><a href=\"https://morven.life/posts/create-your-own-cni-with-golang/\">Create your CNI </a></p>\n</blockquote>\n","cover":false,"excerpt":"","more":"<blockquote>\n<p>使用 Golang 实现一个简易的 CNI<br>对于 CNI 的功能实现将按照循序渐进的方式来进行<br>实现目标</p>\n<ul>\n<li>依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址</li>\n<li>提供容器网络通信服务</li>\n</ul>\n<p>实验的代码和脚本可以在 <a href=\"https://github.com/IdeaMeshDyx/knetwork\">IdeaMeshDyx&#x2F;knetwork</a> 中找到</p>\n</blockquote>\n<h2 id=\"设计简易的-CNI-工作逻辑\"><a href=\"#设计简易的-CNI-工作逻辑\" class=\"headerlink\" title=\"设计简易的 CNI 工作逻辑\"></a>设计简易的 CNI 工作逻辑</h2><p>由于 cni 提供的服务集中于节点的 L2&#x2F;L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。</p>\n<p>依据上一篇<a href=\"https://ideameshdyx.github.io/2023/04/18/EdgeMesh/2023-ospp-fighting/CNI-Basic/\">博客</a>所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：</p>\n<ol>\n<li>kubelet 先创建 pause 容器创建对应的网络命名空间；</li>\n<li>cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；</li>\n<li>当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；</li>\n<li>CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；</li>\n</ol>\n<ul>\n<li>当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。<ul>\n<li>当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接</li>\n<li>当销毁容器的时候，删除为容器分配的所有网络资源</li>\n</ul>\n</li>\n<li>cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)<ul>\n<li>cni 执行的命令和操作(cni必须要实现的核心可调用功能)<ul>\n<li>ADD</li>\n<li>DELETE</li>\n<li>VERSION</li>\n<li>CHECK</li>\n</ul>\n</li>\n<li>容器ID(服务的容器对象ID)</li>\n<li>节点容器所连接网络空间的路径</li>\n<li>容器中需要创建的接口名称</li>\n<li>目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是<code>/opt/cni/bin</code>)</li>\n<li>cni 配置文件的路径</li>\n</ul>\n</li>\n</ul>\n<p>而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。<br>比如 Docker 当中设置 <code>vim /usr/lib/systemd/system/docker.service</code> 中 <code>--bip=10.244.12.1/24 </code> 如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Service]</span><br><span class=\"line\">Type=notify</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">the default is not to use systemd <span class=\"keyword\">for</span> cgroups because the delegate issues still</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">exists and systemd currently does not support the cgroup feature <span class=\"built_in\">set</span> required</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span> containers run by docker</span></span><br><span class=\"line\">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450</span><br><span class=\"line\">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class=\"line\">TimeoutStartSec=0</span><br><span class=\"line\">RestartSec=2</span><br><span class=\"line\">Restart=always</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"Step1-创建-cni-主流程\"><a href=\"#Step1-创建-cni-主流程\" class=\"headerlink\" title=\"Step1 : 创建 cni 主流程\"></a><strong>Step1 : 创建 cni 主流程</strong></h3><p>首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。<br>所以可以先得到一个最基本的 cni 主程序框架如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/containernetworking/cni/pkg/skel&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/containernetworking/cni/pkg/version&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdAdd</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">TODO:</span> add code about cmdAdd</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 测试是否 cni 接收到了传入的容器网络配置参数</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;interfance Name: %s\\n&quot;</span>, args.IfName)</span><br><span class=\"line\">\t  fmt.Printf(<span class=\"string\">&quot;Netns path: %s\\n&quot;</span>, args.Netns)</span><br><span class=\"line\">\t  fmt.Printf(<span class=\"string\">&quot;The config data: %s\\n&quot;</span>, args.StdinData)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdDel</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">TODO:</span> add code about cmdDel</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。</p>\n<p>传入的参数具体内容定义在 <code>pkg/skel/skel.go</code>:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CmdArgs captures all the arguments passed in to the plugin</span></span><br><span class=\"line\"><span class=\"comment\">// via both env vars and stdin</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> CmdArgs <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tContainerID   <span class=\"type\">string</span></span><br><span class=\"line\">\tNetns         <span class=\"type\">string</span></span><br><span class=\"line\">\tIfName        <span class=\"type\">string</span></span><br><span class=\"line\">\tArgs          <span class=\"type\">string</span></span><br><span class=\"line\">\tPath          <span class=\"type\">string</span></span><br><span class=\"line\">\tNetnsOverride <span class=\"type\">string</span></span><br><span class=\"line\">\tStdinData     []<span class=\"type\">byte</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list&#x2F;watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。</p>\n<p>接下来为检验以上的功能逻辑通畅，创建以下 config 文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;mynet&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;BridgeName&quot;:</span> <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;IP&quot;:</span> <span class=\"string\">&quot;192.0.2.1/24&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build -o example .</span><br><span class=\"line\">echo &quot;Ready to call the cni program and create resources&quot;</span><br><span class=\"line\">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class=\"line\">echo &quot;The CNI has been called, see the following results&quot;</span><br></pre></td></tr></table></figure>\n\n<p>得到以下输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# ./run.sh</span><br><span class=\"line\">Ready to call the cni program and create resources</span><br><span class=\"line\">interfance Name: eth10</span><br><span class=\"line\">netns path: /var/run/netns/ns1</span><br><span class=\"line\">the config data: &#123;</span><br><span class=\"line\">        &quot;name&quot;: &quot;mynet&quot;,</span><br><span class=\"line\">        &quot;BridgeName&quot;: &quot;test&quot;,</span><br><span class=\"line\">        &quot;IP&quot;: &quot;192.0.2.1/24&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">The CNI has been called, see the following results</span><br></pre></td></tr></table></figure>\n\n<p>通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。</p>\n<h3 id=\"step2-实现-cmdAdd-功能\"><a href=\"#step2-实现-cmdAdd-功能\" class=\"headerlink\" title=\"step2: 实现 cmdAdd 功能\"></a><strong>step2: 实现 cmdAdd 功能</strong></h3><p>本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：</p>\n<ol>\n<li>从配置中读取网桥信息。</li>\n<li>获取我们想要使用的网桥名称。</li>\n<li>如果系统中不存在该网桥，则创建它。</li>\n</ol>\n<p>由于 cni 的框架里面将配置内容以字节数组的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些字节数组的数据，数据格式需要兼容规范的各类对象。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单的网桥结构</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SimpleBridge <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tBridgeName <span class=\"type\">string</span> <span class=\"string\">`json:&quot;bridgeName&quot;`</span></span><br><span class=\"line\">\tIP         <span class=\"type\">string</span> <span class=\"string\">`json:&quot;ip&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在cmdAdd中解析传入的参数内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdAdd</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">1. 准备好我们想要的 netlink.Bridge 对象。</span></span><br><span class=\"line\"><span class=\"comment\">2. 创建网桥对象</span></span><br><span class=\"line\"><span class=\"comment\">3. 设置Linux网桥参数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">br := &amp;netlink.Bridge&#123;</span><br><span class=\"line\">\tLinkAttrs: netlink.LinkAttrs&#123;</span><br><span class=\"line\">\t\tName: sb.BridgeName,</span><br><span class=\"line\">\t\tMTU:  <span class=\"number\">1500</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// Let kernel use default txqueuelen; leaving it unset</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// means 0, and a zero-length TX queue messes up FIFO</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// traffic shapers which use TX queue length as the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// default packet limit</span></span><br><span class=\"line\">\t\tTxQLen: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">err := netlink.LinkAdd(br)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; err != syscall.EEXIST &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netlink.LinkSetUp(br); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 <code>github.com/containernetworking/cni/pkg/skel</code> 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。<br><a href=\"https://github.com/vishvananda/netlink\">netlink</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">go-cni</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">intel-cni</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">sr-cni</a></p>\n</blockquote>\n<p>到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。</p>\n<p>说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：</p>\n<ol>\n<li>从我们之前创建的Bridge中获取Bridge对象</li>\n<li>获取容器的命名空间</li>\n<li>在容器上创建一个 veth，并将主机端 veth 移至主机 ns。</li>\n<li>将主机端 veth 附加到 linux bridge 上</li>\n</ol>\n<p>在这个过程当中有一些地方需要注意：</p>\n<ul>\n<li>需要检验已创建的网络资源，避免冲突</li>\n<li>获取并处理容器的网络空间</li>\n</ul>\n<p>这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。</p>\n<p>这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取本地的网络设备情况</span></span><br><span class=\"line\">l, err := netlink.LinkByName(sb.BridgeName)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;could not lookup %q: %v&quot;</span>, sb.BridgeName, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较是否有冲突的问题</span></span><br><span class=\"line\">newBr, ok := l.(*netlink.Bridge)</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%q already exists but is not a bridge&quot;</span>, sb.BridgeName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而对于容器网络信息的获取，在之前的指令中也涉及到<code>CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1</code>,这部分信息可以通过传入的参数获取。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netns, err := ns.GetNS(args.Netns)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来对于每一个 <code>NetNs</code>对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]</span></span><br><span class=\"line\">hostIface := &amp;current.Interface&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hostNS ns.NetNS)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\thostVeth, _, err := ip.SetupVeth(args.IfName, <span class=\"number\">1500</span>, hostNS)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thostIface.Name = hostVeth.Name</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为每一个容器调用 handler</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netns.Do(handler); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取所创建的 Bridge </span></span><br><span class=\"line\">hostVeth, err := netlink.LinkByName(hostIface.Name)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 veth 附加到创建的网桥上</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netlink.LinkSetMaster(hostVeth, newBr); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述过程当中，我们通过 <code>hostIface.Name</code> 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 <code>netlink.LinkByName</code> 函数从接口名称中获取链接对象, 然后调用 <code>netlink.LinkSetMaster</code> 函数将链接连接到网桥上。</p>\n<blockquote>\n<p>在操作过程中有一个非常重要的关注点： <strong>确保操作系统不会在命名空间的操作中切换线程</strong><br>可以参考 <a href=\"https://stackoverflow.com/questions/7439608/steps-in-context-switching\">steps-in-context-switching</a> </p>\n<p>命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。</p>\n<p>如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。</p>\n<p>因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。</p>\n</blockquote>\n<p>所以我们使用以下方式限制,具体的使用手册是：<br><a href=\"https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang\">benefits-of-runtime-lockosthread-in-golang</a><br><a href=\"https://pkg.go.dev/runtime\">go-pkg-runtime</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// this ensures that main runs only on main thread (thread group leader).</span></span><br><span class=\"line\">        <span class=\"comment\">// since namespace ops (unshare, setns) are done for a single thread, we</span></span><br><span class=\"line\">        <span class=\"comment\">// must ensure that the goroutine does not jump from OS thread to thread</span></span><br><span class=\"line\">        runtime.LockOSThread()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。</p>\n<p>IP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。<br>这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。</p>\n<p>不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 </p>\n<p>依据上述的逻辑，我们可以得到接下来的代码实现流程：</p>\n<ol>\n<li>依据配置中生成一个IP对象。</li>\n<li>在目标网络命名空间中调用netlink.AddrAdd。</li>\n</ol>\n<p>那么接着看看 <code>netlink</code>  当中是如何实现他对于地址分配的呢？</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 位于 addr.go</span></span><br><span class=\"line\"><span class=\"comment\">// Addr represents an IP address from netlink. Netlink ip addresses</span></span><br><span class=\"line\"><span class=\"comment\">// include a mask, so it stores the address as a net.IPNet.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Addr <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*net.IPNet</span><br><span class=\"line\">\tLabel       <span class=\"type\">string</span></span><br><span class=\"line\">\tFlags       <span class=\"type\">int</span></span><br><span class=\"line\">\tScope       <span class=\"type\">int</span></span><br><span class=\"line\">\tPeer        *net.IPNet</span><br><span class=\"line\">\tBroadcast   net.IP</span><br><span class=\"line\">\tPreferedLft <span class=\"type\">int</span></span><br><span class=\"line\">\tValidLft    <span class=\"type\">int</span></span><br><span class=\"line\">\tLinkIndex   <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 位于 addr_linux.go</span></span><br><span class=\"line\"><span class=\"comment\">// AddrAdd will add an IP address to a link device.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class=\"line\"><span class=\"comment\">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AddrAdd</span><span class=\"params\">(link Link, addr *Addr)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pkgHandle.AddrAdd(link, addr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AddrAdd will add an IP address to a link device.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class=\"line\"><span class=\"comment\">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Handle)</span></span> AddrAdd(link Link, addr *Addr) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.addrHandle(link, addr, req)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们使用 golang 提供的 <code>net</code> 包来生成 <code>net.IPNet</code> 类型和它的CIDR形式（IP地址和Mask），然后通过 <code>net.ParseCIDR</code> 来解析配置文件中获取的IP字符串并返回一个 <code>net.IPNet</code> 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 <code>net.ParseCIDR</code> 得到的 <code>net.IPNet</code> 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hostNS ns.NetNS)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, <span class=\"number\">1500</span>, hostNS)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hostIface.Name = hostVeth.Name</span><br><span class=\"line\">    <span class=\"comment\">// 在这里创建 IP  地址对象</span></span><br><span class=\"line\">    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    link, err := netlink.LinkByName(containerVeth.Name)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 IP 地址</span></span><br><span class=\"line\">    ipv4Net.IP = ipv4Addr</span><br><span class=\"line\"></span><br><span class=\"line\">    addr := &amp;netlink.Addr&#123;IPNet: ipv4Net, Label: <span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err = netlink.AddrAdd(link, addr); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里，一个基础且完整的 <code>cmdAdd</code> 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除先前创建的资源</span></span><br><span class=\"line\">sudo ip netns del ns1</span><br><span class=\"line\">sudo ifconfig test down</span><br><span class=\"line\">sudo brctl delbr test</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重新创建 ns1 来模拟容器</span></span><br><span class=\"line\">sudo ip netns add ns1</span><br><span class=\"line\">go build -o example .</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">执行 cni 来生成地址</span></span><br><span class=\"line\">echo &quot;Ready to call the cni to create ip for ns1&quot;</span><br><span class=\"line\">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class=\"line\">echo &quot;The CNI has been called, see the following results&quot;</span><br><span class=\"line\">echo &quot;The bridge and the veth has been attatch to&quot;</span><br><span class=\"line\">sudo brctl show test</span><br><span class=\"line\">echo &quot;The interface in the netns&quot;</span><br><span class=\"line\">sudo ip netns exec ns1 ifconfig -a</span><br></pre></td></tr></table></figure>\n\n<p>执行的结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# ./run.sh </span><br><span class=\"line\">Cannot remove namespace file &quot;/var/run/netns/ns1&quot;: No such file or directory</span><br><span class=\"line\">test: ERROR while getting interface flags: No such device</span><br><span class=\"line\">bridge test doesn&#x27;t exist; can&#x27;t delete it</span><br><span class=\"line\">Ready to call the cni to create ip for ns1</span><br><span class=\"line\">&#123;test 192.0.2.15/24&#125;</span><br><span class=\"line\">The CNI has been called, see the following results</span><br><span class=\"line\">The bridge and the veth has been attatch to</span><br><span class=\"line\">bridge name     bridge id               STP enabled     interfaces</span><br><span class=\"line\">test            8000.b6e6090625de       no              veth2a9d8a3d</span><br><span class=\"line\">The interface in the netns</span><br><span class=\"line\">eth10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255</span><br><span class=\"line\">        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)</span><br><span class=\"line\">        RX packets 1  bytes 90 (90.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 1  bytes 90 (90.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags=8&lt;LOOPBACK&gt;  mtu 65536</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>\n\n<p>可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# sudo ifconfig test 192.0.2.1</span><br><span class=\"line\">[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1</span><br><span class=\"line\">PING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms</span><br><span class=\"line\">^C</span><br><span class=\"line\">--- 192.0.2.1 ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 received, 0% packet loss, ti</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>主要参考文章：<br><a href=\"https://www.hwchiu.com/introduce-cni-iii.html\">Container Network Interface</a><br><a href=\"https://morven.life/posts/create-your-own-cni-with-golang/\">Create your CNI </a></p>\n</blockquote>\n"},{"title":"Docker 环境下配置 Hexo 博客","date":"2024-04-11T08:15:14.000Z","_content":"\n# Hexo Blog\n\n> 记录博客搭建管理的技术栈和流程\n>\n> 博客的技术方案选择： [Hexo+github.io][https://hexo.io/zh-cn/]\n>\n> 博客模板选择： [Butterfly][https://butterfly.js.org/]\n>\n> 博客文件管理模式： \n> * 使用 docker环境管理：[独立使用 docker 编译环境][https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo]\n\n首先是选择一个合适的博客管理技术栈，实际上借用已有的博客平台比如[掘金][https://juejin.cn/],[开源中国][https://www.oschina.net/],[CSDN][https://www.csdn.net/] 等可以节省自己部署成本，但是这些平台太过于复杂且页面风格等方面难以符合自己的需求，最重要的是太过于复杂和笨重。\n\n使用静态博客需要花费更多的精力，但是也可以更贴近开发方式，也可以作为部分技术点的试验方式，故选用这个需要折腾的方式。目前最为著名的两个技术栈是：\n\n- Jekyll：42.6k [Github地址](https://link.zhihu.com/?target=https%3A//github.com/jekyll/jekyll)/[官网地址](https://link.zhihu.com/?target=https%3A//jekyllrb.com/)\n- Hexo：32.6k [Github地址](https://link.zhihu.com/?target=https%3A//github.com/hexojs/hexo)/[官网地址](https://link.zhihu.com/?target=https%3A//hexo.io/)\n\n其中 Jekyll 有github支持，可以直接在github网页上编辑，但是技术要求较高，后期等到博客管理维护的方法论和技术流程成熟了就切换成这个试试。Hexo基于node.js 实现，有非常多的教程和资料，许多操作都做了封装和优化，可以在本地进行调试，作为学习和测试的方式来说非常适合。其他博客技术对比资料参考[静态博客搭建工具汇总](https://www.cnblogs.com/FLY_DREAM/p/16527100.html),[Top ten popular static site generators (SSG) in 2023][https://medium.com/@ezinneanne/top-ten-popular-static-site-generators-ssg-in-2023-e1894fca6925],[Jekyll / Hugo / Hexo Comparison][https://lexcao.io/posts/jekyll-hugo-hexo/],[Gatsby, Ghost, Hugo, Jekyll or another static site generator?][https://www.reddit.com/r/webdev/comments/10qpeu9/gatsby_ghost_hugo_jekyll_or_another_static_site/]\n\n\n\n##  Docker 管理环境\n\n不论选用哪一类技术，当切换设备和环境的时候，以往部署的 ruby，nodejs 环境就需要重新部署，而这往往是成本最高的地方，容易受到操作系统、设备硬件、网络状态的影响，所以采用 Docker 镜像做统一的管理。 \n\nDocker 管理的方式是 Docker 内配置博客需要的所有的环境依赖，包括nodejs、ruby、github sshkey等等，然后通过挂载本地博客项目文件的方式来获取源文件，这样就可以使用本地 IDE 编辑文件，然后利用 Docker 环境编译生成和部署。\n\nDocker 环境部署参考：https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo\n\n也可以直接使用本博客目录下面的`docker-compose.yml`来启动\n\n\n## Markdown文章内容\n\n简单的模板, 配置在`/scafffolds/post.md` 中\n\n``` markdown\n---\ntitle: {{ title }}\ndate: {{ date }}\nauthor: \nimg: \ncoverImg: \ntop: false\ncover: false\ntoc: true\nmathjax: false\npassword:\nsummary:\ntags:\ncategories:\n---\n\n```\n\n然后每次使用 `hexo new` 创建新的博客时候就会采用这个格式\n\n\n\n## github + hexo 部署流程\n\n当完成了博客的内容编写之后，需要编译静态文件同时发布的github上，遵循以下流程：\n\n```\n# 所有的修改都在 blog 分支上进行\ngit checkout blog\n\n# 先保存已有的修改\ngit status\ngit add .  # 或者是 add 修改地文件\ngit commit -m \"\"  --signoff\n\n# 然后生成文件\nhexo c # 清理之前的 cache\nhexo g\nhexo s\n\n# 此后可以直接访问 localhost:4000 查看博客的具体样式，依据样式修改\n\n# status 应该显示没有修改，是update\ngit status\ngit push origin/blog\n```\n\n然后在github上需要通过配置 workflow 流程来编译文件\n具体操作是：\n1. 建立 <你的 GitHub 使用者名称>.github.io 的仓库，username 是你在 GitHub 上的使用者名称，若之前已將 Hexo 上传至其他仓库，那就改个名字。\n2. 將本地的 Hexo 项目 push 到仓库的预设分支，预设分支通常名為 main，旧一點的仓库可能名為 master。\n將 main 分支 push 到 GitHub：\n```\n$ git push -u origin main\n```\n为了保障 `hexo s` 生成的文件不会上传到远程仓库，预设情況下 public/文件目录 不会被上传(也不该被上传)，保证 .gitignore 中有一行 public/就可以实现了。\n可以直接参考本博客的目录结构来看是否配置正确。\n3. 使用 node --version 指令检查Docker上的 Node.js 版本（目前我用的是 20）。之后到github 网页的仓库中 Settings > Pages > Source，並将 Source 改为 GitHub Actions。\n\n然后在仓库中创建 .github/workflows/pages.yml，並填入以下內容 (將 20 替换为上述步驟中记下的版本)：\n``` yaml\nname: Pages\n\non:\n  push:\n    branches:\n      - main # default branch\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          # If your repository depends on submodule, please see: https://github.com/actions/checkout\n          submodules: recursive\n      - name: Use Node.js 20.x\n        uses: actions/setup-node@v2\n        with:\n          node-version: '20'\n      - name: Cache NPM dependencies\n        uses: actions/cache@v2\n        with:\n          path: node_modules\n          key: ${{ runner.OS }}-npm-cache\n          restore-keys: |\n            ${{ runner.OS }}-npm-cache\n      - name: Install Dependencies\n        run: npm install\n      - name: Build\n        run: npm run build\n      - name: Upload Pages artifact\n        uses: actions/upload-pages-artifact@v2\n        with:\n          path: ./public\n  deploy:\n    needs: build\n    permissions:\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v2\n```\n\n这个也是学习 github workflow  的一个好机会。\n部署完成之后，每一次提交pr都会触发github编译这个环境，就不需要使用 hexo d 来完成推送了。\n","source":"_posts/2024/04/hexo-with-docker.md","raw":"---\ntitle: Docker 环境下配置 Hexo 博客\ndate: 2024-04-11 16:15:14\ntags: Hexo, Blog, docker\ncategories: Blog\n---\n\n# Hexo Blog\n\n> 记录博客搭建管理的技术栈和流程\n>\n> 博客的技术方案选择： [Hexo+github.io][https://hexo.io/zh-cn/]\n>\n> 博客模板选择： [Butterfly][https://butterfly.js.org/]\n>\n> 博客文件管理模式： \n> * 使用 docker环境管理：[独立使用 docker 编译环境][https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo]\n\n首先是选择一个合适的博客管理技术栈，实际上借用已有的博客平台比如[掘金][https://juejin.cn/],[开源中国][https://www.oschina.net/],[CSDN][https://www.csdn.net/] 等可以节省自己部署成本，但是这些平台太过于复杂且页面风格等方面难以符合自己的需求，最重要的是太过于复杂和笨重。\n\n使用静态博客需要花费更多的精力，但是也可以更贴近开发方式，也可以作为部分技术点的试验方式，故选用这个需要折腾的方式。目前最为著名的两个技术栈是：\n\n- Jekyll：42.6k [Github地址](https://link.zhihu.com/?target=https%3A//github.com/jekyll/jekyll)/[官网地址](https://link.zhihu.com/?target=https%3A//jekyllrb.com/)\n- Hexo：32.6k [Github地址](https://link.zhihu.com/?target=https%3A//github.com/hexojs/hexo)/[官网地址](https://link.zhihu.com/?target=https%3A//hexo.io/)\n\n其中 Jekyll 有github支持，可以直接在github网页上编辑，但是技术要求较高，后期等到博客管理维护的方法论和技术流程成熟了就切换成这个试试。Hexo基于node.js 实现，有非常多的教程和资料，许多操作都做了封装和优化，可以在本地进行调试，作为学习和测试的方式来说非常适合。其他博客技术对比资料参考[静态博客搭建工具汇总](https://www.cnblogs.com/FLY_DREAM/p/16527100.html),[Top ten popular static site generators (SSG) in 2023][https://medium.com/@ezinneanne/top-ten-popular-static-site-generators-ssg-in-2023-e1894fca6925],[Jekyll / Hugo / Hexo Comparison][https://lexcao.io/posts/jekyll-hugo-hexo/],[Gatsby, Ghost, Hugo, Jekyll or another static site generator?][https://www.reddit.com/r/webdev/comments/10qpeu9/gatsby_ghost_hugo_jekyll_or_another_static_site/]\n\n\n\n##  Docker 管理环境\n\n不论选用哪一类技术，当切换设备和环境的时候，以往部署的 ruby，nodejs 环境就需要重新部署，而这往往是成本最高的地方，容易受到操作系统、设备硬件、网络状态的影响，所以采用 Docker 镜像做统一的管理。 \n\nDocker 管理的方式是 Docker 内配置博客需要的所有的环境依赖，包括nodejs、ruby、github sshkey等等，然后通过挂载本地博客项目文件的方式来获取源文件，这样就可以使用本地 IDE 编辑文件，然后利用 Docker 环境编译生成和部署。\n\nDocker 环境部署参考：https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo\n\n也可以直接使用本博客目录下面的`docker-compose.yml`来启动\n\n\n## Markdown文章内容\n\n简单的模板, 配置在`/scafffolds/post.md` 中\n\n``` markdown\n---\ntitle: {{ title }}\ndate: {{ date }}\nauthor: \nimg: \ncoverImg: \ntop: false\ncover: false\ntoc: true\nmathjax: false\npassword:\nsummary:\ntags:\ncategories:\n---\n\n```\n\n然后每次使用 `hexo new` 创建新的博客时候就会采用这个格式\n\n\n\n## github + hexo 部署流程\n\n当完成了博客的内容编写之后，需要编译静态文件同时发布的github上，遵循以下流程：\n\n```\n# 所有的修改都在 blog 分支上进行\ngit checkout blog\n\n# 先保存已有的修改\ngit status\ngit add .  # 或者是 add 修改地文件\ngit commit -m \"\"  --signoff\n\n# 然后生成文件\nhexo c # 清理之前的 cache\nhexo g\nhexo s\n\n# 此后可以直接访问 localhost:4000 查看博客的具体样式，依据样式修改\n\n# status 应该显示没有修改，是update\ngit status\ngit push origin/blog\n```\n\n然后在github上需要通过配置 workflow 流程来编译文件\n具体操作是：\n1. 建立 <你的 GitHub 使用者名称>.github.io 的仓库，username 是你在 GitHub 上的使用者名称，若之前已將 Hexo 上传至其他仓库，那就改个名字。\n2. 將本地的 Hexo 项目 push 到仓库的预设分支，预设分支通常名為 main，旧一點的仓库可能名為 master。\n將 main 分支 push 到 GitHub：\n```\n$ git push -u origin main\n```\n为了保障 `hexo s` 生成的文件不会上传到远程仓库，预设情況下 public/文件目录 不会被上传(也不该被上传)，保证 .gitignore 中有一行 public/就可以实现了。\n可以直接参考本博客的目录结构来看是否配置正确。\n3. 使用 node --version 指令检查Docker上的 Node.js 版本（目前我用的是 20）。之后到github 网页的仓库中 Settings > Pages > Source，並将 Source 改为 GitHub Actions。\n\n然后在仓库中创建 .github/workflows/pages.yml，並填入以下內容 (將 20 替换为上述步驟中记下的版本)：\n``` yaml\nname: Pages\n\non:\n  push:\n    branches:\n      - main # default branch\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          # If your repository depends on submodule, please see: https://github.com/actions/checkout\n          submodules: recursive\n      - name: Use Node.js 20.x\n        uses: actions/setup-node@v2\n        with:\n          node-version: '20'\n      - name: Cache NPM dependencies\n        uses: actions/cache@v2\n        with:\n          path: node_modules\n          key: ${{ runner.OS }}-npm-cache\n          restore-keys: |\n            ${{ runner.OS }}-npm-cache\n      - name: Install Dependencies\n        run: npm install\n      - name: Build\n        run: npm run build\n      - name: Upload Pages artifact\n        uses: actions/upload-pages-artifact@v2\n        with:\n          path: ./public\n  deploy:\n    needs: build\n    permissions:\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v2\n```\n\n这个也是学习 github workflow  的一个好机会。\n部署完成之后，每一次提交pr都会触发github编译这个环境，就不需要使用 hexo d 来完成推送了。\n","slug":"hexo-with-docker","published":1,"updated":"2024-04-11T14:20:49.387Z","_id":"cluv14vfi000b52pedgek3jlr","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Hexo-Blog\"><a href=\"#Hexo-Blog\" class=\"headerlink\" title=\"Hexo Blog\"></a>Hexo Blog</h1><blockquote>\n<p>记录博客搭建管理的技术栈和流程</p>\n<p>博客的技术方案选择： [Hexo+github.io][<a href=\"https://hexo.io/zh-cn/]\">https://hexo.io/zh-cn/]</a></p>\n<p>博客模板选择： [Butterfly][<a href=\"https://butterfly.js.org/]\">https://butterfly.js.org/]</a></p>\n<p>博客文件管理模式： </p>\n<ul>\n<li>使用 docker环境管理：[独立使用 docker 编译环境][<a href=\"https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo]\">https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo]</a></li>\n</ul>\n</blockquote>\n<p>首先是选择一个合适的博客管理技术栈，实际上借用已有的博客平台比如[掘金][<a href=\"https://juejin.cn/],[%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD][https://www.oschina.net/],[CSDN][https://www.csdn.net/]\">https://juejin.cn/],[开源中国][https://www.oschina.net/],[CSDN][https://www.csdn.net/]</a> 等可以节省自己部署成本，但是这些平台太过于复杂且页面风格等方面难以符合自己的需求，最重要的是太过于复杂和笨重。</p>\n<p>使用静态博客需要花费更多的精力，但是也可以更贴近开发方式，也可以作为部分技术点的试验方式，故选用这个需要折腾的方式。目前最为著名的两个技术栈是：</p>\n<ul>\n<li>Jekyll：42.6k <a href=\"https://link.zhihu.com/?target=https://github.com/jekyll/jekyll\">Github地址</a>&#x2F;<a href=\"https://link.zhihu.com/?target=https://jekyllrb.com/\">官网地址</a></li>\n<li>Hexo：32.6k <a href=\"https://link.zhihu.com/?target=https://github.com/hexojs/hexo\">Github地址</a>&#x2F;<a href=\"https://link.zhihu.com/?target=https://hexo.io/\">官网地址</a></li>\n</ul>\n<p>其中 Jekyll 有github支持，可以直接在github网页上编辑，但是技术要求较高，后期等到博客管理维护的方法论和技术流程成熟了就切换成这个试试。Hexo基于node.js 实现，有非常多的教程和资料，许多操作都做了封装和优化，可以在本地进行调试，作为学习和测试的方式来说非常适合。其他博客技术对比资料参考<a href=\"https://www.cnblogs.com/FLY_DREAM/p/16527100.html\">静态博客搭建工具汇总</a>,[Top ten popular static site generators (SSG) in 2023][<a href=\"https://medium.com/@ezinneanne/top-ten-popular-static-site-generators-ssg-in-2023-e1894fca6925],[Jekyll\">https://medium.com/@ezinneanne/top-ten-popular-static-site-generators-ssg-in-2023-e1894fca6925],[Jekyll</a> &#x2F; Hugo &#x2F; Hexo Comparison][<a href=\"https://lexcao.io/posts/jekyll-hugo-hexo/],[Gatsby\">https://lexcao.io/posts/jekyll-hugo-hexo/],[Gatsby</a>, Ghost, Hugo, Jekyll or another static site generator?][<a href=\"https://www.reddit.com/r/webdev/comments/10qpeu9/gatsby_ghost_hugo_jekyll_or_another_static_site/]\">https://www.reddit.com/r/webdev/comments/10qpeu9/gatsby_ghost_hugo_jekyll_or_another_static_site/]</a></p>\n<h2 id=\"Docker-管理环境\"><a href=\"#Docker-管理环境\" class=\"headerlink\" title=\"Docker 管理环境\"></a>Docker 管理环境</h2><p>不论选用哪一类技术，当切换设备和环境的时候，以往部署的 ruby，nodejs 环境就需要重新部署，而这往往是成本最高的地方，容易受到操作系统、设备硬件、网络状态的影响，所以采用 Docker 镜像做统一的管理。 </p>\n<p>Docker 管理的方式是 Docker 内配置博客需要的所有的环境依赖，包括nodejs、ruby、github sshkey等等，然后通过挂载本地博客项目文件的方式来获取源文件，这样就可以使用本地 IDE 编辑文件，然后利用 Docker 环境编译生成和部署。</p>\n<p>Docker 环境部署参考：<a href=\"https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo\">https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo</a></p>\n<p>也可以直接使用本博客目录下面的<code>docker-compose.yml</code>来启动</p>\n<h2 id=\"Markdown文章内容\"><a href=\"#Markdown文章内容\" class=\"headerlink\" title=\"Markdown文章内容\"></a>Markdown文章内容</h2><p>简单的模板, 配置在<code>/scafffolds/post.md</code> 中</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">date: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">author: </span><br><span class=\"line\">img: </span><br><span class=\"line\">coverImg: </span><br><span class=\"line\">top: false</span><br><span class=\"line\">cover: false</span><br><span class=\"line\">toc: true</span><br><span class=\"line\">mathjax: false</span><br><span class=\"line\">password:</span><br><span class=\"line\">summary:</span><br><span class=\"line\">tags:</span><br><span class=\"line\"><span class=\"section\">categories:</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后每次使用 <code>hexo new</code> 创建新的博客时候就会采用这个格式</p>\n<h2 id=\"github-hexo-部署流程\"><a href=\"#github-hexo-部署流程\" class=\"headerlink\" title=\"github + hexo 部署流程\"></a>github + hexo 部署流程</h2><p>当完成了博客的内容编写之后，需要编译静态文件同时发布的github上，遵循以下流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 所有的修改都在 blog 分支上进行</span><br><span class=\"line\">git checkout blog</span><br><span class=\"line\"></span><br><span class=\"line\"># 先保存已有的修改</span><br><span class=\"line\">git status</span><br><span class=\"line\">git add .  # 或者是 add 修改地文件</span><br><span class=\"line\">git commit -m &quot;&quot;  --signoff</span><br><span class=\"line\"></span><br><span class=\"line\"># 然后生成文件</span><br><span class=\"line\">hexo c # 清理之前的 cache</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br><span class=\"line\"></span><br><span class=\"line\"># 此后可以直接访问 localhost:4000 查看博客的具体样式，依据样式修改</span><br><span class=\"line\"></span><br><span class=\"line\"># status 应该显示没有修改，是update</span><br><span class=\"line\">git status</span><br><span class=\"line\">git push origin/blog</span><br></pre></td></tr></table></figure>\n\n<p>然后在github上需要通过配置 workflow 流程来编译文件<br>具体操作是：</p>\n<ol>\n<li>建立 &lt;你的 GitHub 使用者名称&gt;.github.io 的仓库，username 是你在 GitHub 上的使用者名称，若之前已將 Hexo 上传至其他仓库，那就改个名字。</li>\n<li>將本地的 Hexo 项目 push 到仓库的预设分支，预设分支通常名為 main，旧一點的仓库可能名為 master。<br>將 main 分支 push 到 GitHub：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -u origin main</span><br></pre></td></tr></table></figure>\n为了保障 <code>hexo s</code> 生成的文件不会上传到远程仓库，预设情況下 public&#x2F;文件目录 不会被上传(也不该被上传)，保证 .gitignore 中有一行 public&#x2F;就可以实现了。<br>可以直接参考本博客的目录结构来看是否配置正确。</li>\n<li>使用 node –version 指令检查Docker上的 Node.js 版本（目前我用的是 20）。之后到github 网页的仓库中 Settings &gt; Pages &gt; Source，並将 Source 改为 GitHub Actions。</li>\n</ol>\n<p>然后在仓库中创建 .github&#x2F;workflows&#x2F;pages.yml，並填入以下內容 (將 20 替换为上述步驟中记下的版本)：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Pages</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">main</span> <span class=\"comment\"># default branch</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v3</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">token:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"comment\"># If your repository depends on submodule, please see: https://github.com/actions/checkout</span></span><br><span class=\"line\">          <span class=\"attr\">submodules:</span> <span class=\"string\">recursive</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Use</span> <span class=\"string\">Node.js</span> <span class=\"number\">20.</span><span class=\"string\">x</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">node-version:</span> <span class=\"string\">&#x27;20&#x27;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Cache</span> <span class=\"string\">NPM</span> <span class=\"string\">dependencies</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/cache@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">node_modules</span></span><br><span class=\"line\">          <span class=\"attr\">key:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">runner.OS</span> <span class=\"string\">&#125;&#125;-npm-cache</span></span><br><span class=\"line\">          <span class=\"attr\">restore-keys:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class=\"line\"><span class=\"string\"></span>      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Install</span> <span class=\"string\">Dependencies</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Build</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">Pages</span> <span class=\"string\">artifact</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/upload-pages-artifact@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">./public</span></span><br><span class=\"line\">  <span class=\"attr\">deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">needs:</span> <span class=\"string\">build</span></span><br><span class=\"line\">    <span class=\"attr\">permissions:</span></span><br><span class=\"line\">      <span class=\"attr\">pages:</span> <span class=\"string\">write</span></span><br><span class=\"line\">      <span class=\"attr\">id-token:</span> <span class=\"string\">write</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">github-pages</span></span><br><span class=\"line\">      <span class=\"attr\">url:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.deployment.outputs.page_url</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">to</span> <span class=\"string\">GitHub</span> <span class=\"string\">Pages</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">deployment</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/deploy-pages@v2</span></span><br></pre></td></tr></table></figure>\n\n<p>这个也是学习 github workflow  的一个好机会。<br>部署完成之后，每一次提交pr都会触发github编译这个环境，就不需要使用 hexo d 来完成推送了。</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"Hexo-Blog\"><a href=\"#Hexo-Blog\" class=\"headerlink\" title=\"Hexo Blog\"></a>Hexo Blog</h1><blockquote>\n<p>记录博客搭建管理的技术栈和流程</p>\n<p>博客的技术方案选择： [Hexo+github.io][<a href=\"https://hexo.io/zh-cn/]\">https://hexo.io/zh-cn/]</a></p>\n<p>博客模板选择： [Butterfly][<a href=\"https://butterfly.js.org/]\">https://butterfly.js.org/]</a></p>\n<p>博客文件管理模式： </p>\n<ul>\n<li>使用 docker环境管理：[独立使用 docker 编译环境][<a href=\"https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo]\">https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo]</a></li>\n</ul>\n</blockquote>\n<p>首先是选择一个合适的博客管理技术栈，实际上借用已有的博客平台比如[掘金][<a href=\"https://juejin.cn/],[%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD][https://www.oschina.net/],[CSDN][https://www.csdn.net/]\">https://juejin.cn/],[开源中国][https://www.oschina.net/],[CSDN][https://www.csdn.net/]</a> 等可以节省自己部署成本，但是这些平台太过于复杂且页面风格等方面难以符合自己的需求，最重要的是太过于复杂和笨重。</p>\n<p>使用静态博客需要花费更多的精力，但是也可以更贴近开发方式，也可以作为部分技术点的试验方式，故选用这个需要折腾的方式。目前最为著名的两个技术栈是：</p>\n<ul>\n<li>Jekyll：42.6k <a href=\"https://link.zhihu.com/?target=https://github.com/jekyll/jekyll\">Github地址</a>&#x2F;<a href=\"https://link.zhihu.com/?target=https://jekyllrb.com/\">官网地址</a></li>\n<li>Hexo：32.6k <a href=\"https://link.zhihu.com/?target=https://github.com/hexojs/hexo\">Github地址</a>&#x2F;<a href=\"https://link.zhihu.com/?target=https://hexo.io/\">官网地址</a></li>\n</ul>\n<p>其中 Jekyll 有github支持，可以直接在github网页上编辑，但是技术要求较高，后期等到博客管理维护的方法论和技术流程成熟了就切换成这个试试。Hexo基于node.js 实现，有非常多的教程和资料，许多操作都做了封装和优化，可以在本地进行调试，作为学习和测试的方式来说非常适合。其他博客技术对比资料参考<a href=\"https://www.cnblogs.com/FLY_DREAM/p/16527100.html\">静态博客搭建工具汇总</a>,[Top ten popular static site generators (SSG) in 2023][<a href=\"https://medium.com/@ezinneanne/top-ten-popular-static-site-generators-ssg-in-2023-e1894fca6925],[Jekyll\">https://medium.com/@ezinneanne/top-ten-popular-static-site-generators-ssg-in-2023-e1894fca6925],[Jekyll</a> &#x2F; Hugo &#x2F; Hexo Comparison][<a href=\"https://lexcao.io/posts/jekyll-hugo-hexo/],[Gatsby\">https://lexcao.io/posts/jekyll-hugo-hexo/],[Gatsby</a>, Ghost, Hugo, Jekyll or another static site generator?][<a href=\"https://www.reddit.com/r/webdev/comments/10qpeu9/gatsby_ghost_hugo_jekyll_or_another_static_site/]\">https://www.reddit.com/r/webdev/comments/10qpeu9/gatsby_ghost_hugo_jekyll_or_another_static_site/]</a></p>\n<h2 id=\"Docker-管理环境\"><a href=\"#Docker-管理环境\" class=\"headerlink\" title=\"Docker 管理环境\"></a>Docker 管理环境</h2><p>不论选用哪一类技术，当切换设备和环境的时候，以往部署的 ruby，nodejs 环境就需要重新部署，而这往往是成本最高的地方，容易受到操作系统、设备硬件、网络状态的影响，所以采用 Docker 镜像做统一的管理。 </p>\n<p>Docker 管理的方式是 Docker 内配置博客需要的所有的环境依赖，包括nodejs、ruby、github sshkey等等，然后通过挂载本地博客项目文件的方式来获取源文件，这样就可以使用本地 IDE 编辑文件，然后利用 Docker 环境编译生成和部署。</p>\n<p>Docker 环境部署参考：<a href=\"https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo\">https://github.com/IdeaMeshDyx/dev-enviroment/tree/main/hexo</a></p>\n<p>也可以直接使用本博客目录下面的<code>docker-compose.yml</code>来启动</p>\n<h2 id=\"Markdown文章内容\"><a href=\"#Markdown文章内容\" class=\"headerlink\" title=\"Markdown文章内容\"></a>Markdown文章内容</h2><p>简单的模板, 配置在<code>/scafffolds/post.md</code> 中</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">date: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">author: </span><br><span class=\"line\">img: </span><br><span class=\"line\">coverImg: </span><br><span class=\"line\">top: false</span><br><span class=\"line\">cover: false</span><br><span class=\"line\">toc: true</span><br><span class=\"line\">mathjax: false</span><br><span class=\"line\">password:</span><br><span class=\"line\">summary:</span><br><span class=\"line\">tags:</span><br><span class=\"line\"><span class=\"section\">categories:</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后每次使用 <code>hexo new</code> 创建新的博客时候就会采用这个格式</p>\n<h2 id=\"github-hexo-部署流程\"><a href=\"#github-hexo-部署流程\" class=\"headerlink\" title=\"github + hexo 部署流程\"></a>github + hexo 部署流程</h2><p>当完成了博客的内容编写之后，需要编译静态文件同时发布的github上，遵循以下流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 所有的修改都在 blog 分支上进行</span><br><span class=\"line\">git checkout blog</span><br><span class=\"line\"></span><br><span class=\"line\"># 先保存已有的修改</span><br><span class=\"line\">git status</span><br><span class=\"line\">git add .  # 或者是 add 修改地文件</span><br><span class=\"line\">git commit -m &quot;&quot;  --signoff</span><br><span class=\"line\"></span><br><span class=\"line\"># 然后生成文件</span><br><span class=\"line\">hexo c # 清理之前的 cache</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br><span class=\"line\"></span><br><span class=\"line\"># 此后可以直接访问 localhost:4000 查看博客的具体样式，依据样式修改</span><br><span class=\"line\"></span><br><span class=\"line\"># status 应该显示没有修改，是update</span><br><span class=\"line\">git status</span><br><span class=\"line\">git push origin/blog</span><br></pre></td></tr></table></figure>\n\n<p>然后在github上需要通过配置 workflow 流程来编译文件<br>具体操作是：</p>\n<ol>\n<li>建立 &lt;你的 GitHub 使用者名称&gt;.github.io 的仓库，username 是你在 GitHub 上的使用者名称，若之前已將 Hexo 上传至其他仓库，那就改个名字。</li>\n<li>將本地的 Hexo 项目 push 到仓库的预设分支，预设分支通常名為 main，旧一點的仓库可能名為 master。<br>將 main 分支 push 到 GitHub：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -u origin main</span><br></pre></td></tr></table></figure>\n为了保障 <code>hexo s</code> 生成的文件不会上传到远程仓库，预设情況下 public&#x2F;文件目录 不会被上传(也不该被上传)，保证 .gitignore 中有一行 public&#x2F;就可以实现了。<br>可以直接参考本博客的目录结构来看是否配置正确。</li>\n<li>使用 node –version 指令检查Docker上的 Node.js 版本（目前我用的是 20）。之后到github 网页的仓库中 Settings &gt; Pages &gt; Source，並将 Source 改为 GitHub Actions。</li>\n</ol>\n<p>然后在仓库中创建 .github&#x2F;workflows&#x2F;pages.yml，並填入以下內容 (將 20 替换为上述步驟中记下的版本)：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Pages</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">main</span> <span class=\"comment\"># default branch</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v3</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">token:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"comment\"># If your repository depends on submodule, please see: https://github.com/actions/checkout</span></span><br><span class=\"line\">          <span class=\"attr\">submodules:</span> <span class=\"string\">recursive</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Use</span> <span class=\"string\">Node.js</span> <span class=\"number\">20.</span><span class=\"string\">x</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">node-version:</span> <span class=\"string\">&#x27;20&#x27;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Cache</span> <span class=\"string\">NPM</span> <span class=\"string\">dependencies</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/cache@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">node_modules</span></span><br><span class=\"line\">          <span class=\"attr\">key:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">runner.OS</span> <span class=\"string\">&#125;&#125;-npm-cache</span></span><br><span class=\"line\">          <span class=\"attr\">restore-keys:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class=\"line\"><span class=\"string\"></span>      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Install</span> <span class=\"string\">Dependencies</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Build</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">Pages</span> <span class=\"string\">artifact</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/upload-pages-artifact@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">./public</span></span><br><span class=\"line\">  <span class=\"attr\">deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">needs:</span> <span class=\"string\">build</span></span><br><span class=\"line\">    <span class=\"attr\">permissions:</span></span><br><span class=\"line\">      <span class=\"attr\">pages:</span> <span class=\"string\">write</span></span><br><span class=\"line\">      <span class=\"attr\">id-token:</span> <span class=\"string\">write</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">github-pages</span></span><br><span class=\"line\">      <span class=\"attr\">url:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.deployment.outputs.page_url</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">to</span> <span class=\"string\">GitHub</span> <span class=\"string\">Pages</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">deployment</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/deploy-pages@v2</span></span><br></pre></td></tr></table></figure>\n\n<p>这个也是学习 github workflow  的一个好机会。<br>部署完成之后，每一次提交pr都会触发github编译这个环境，就不需要使用 hexo d 来完成推送了。</p>\n"},{"title":"CNI 与  Pod 容器网络—— Linux 网络","date":"2024-04-11T14:17:51.000Z","catalog":true,"_content":"\n# CNI 与  Pod 容器网络—— Linux 网络\n\n> Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? \n>\n> 如何保障 Pod IP 在整个集群当中的唯一性？\n>\n> 容器流量如何在所给的IP之间相互转发？\n\n---\n\n## 从 namespace 开始\n\nnamespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：\n\n``` bash\n       Linux provides the following namespaces:\n\n       Namespace   Constant          Isolates\n       Cgroup      CLONE_NEWCGROUP   Cgroup root directory\n       IPC         CLONE_NEWIPC      System V IPC, POSIX message queues\n       Network     CLONE_NEWNET      Network devices, stacks, ports, etc.\n       Mount       CLONE_NEWNS       Mount points\n       PID         CLONE_NEWPID      Process IDs\n       User        CLONE_NEWUSER     User and group IDs\n       UTS         CLONE_NEWUTS      Hostname and NIS domain name\n```\n\n其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。\n\n在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 **netns** 执行对 networkname space  的各项增删改查。\n\n依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？\n\n---\n\n## veth 的创建和连接\n\n首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过` ip link add veth0 type veth peer name veth1` 等指令来创建管理这些虚拟网卡，eg ：[从docker0开始](https://morningspace.github.io/tech/k8s-net-docker0/) ，[Deep dive into Linux Networking and Docker | Medium](https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72) 等文章就有讲到其作用和类似操作，不再复述。\n\n但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：[veth(4) - Linux manual page (man7.org)](https://man7.org/linux/man-pages/man4/veth.4.html)，[linux/veth.c at master · torvalds/linux (github.com)](https://github.com/torvalds/linux/blob/master/drivers/net/veth.c)\n\nveth的相关源码位于 `drivers/net/veth.c`中，其中的初始化入口是`veth_init`\n\n``` c\nstatic __init int veth_init(void)\n{\n\treturn rtnl_link_register(&veth_link_ops);\n}\n```\n\n初始化函数注册了`veth_link_ops`(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:\n\n```c\nstatic struct rtnl_link_ops veth_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct veth_priv),\n\t.setup\t\t= veth_setup,\n\t.validate\t= veth_validate,\n\t.newlink\t= veth_newlink,\n\t.dellink\t= veth_dellink,\n\t.policy\t\t= veth_policy,\n\t.maxtype\t= VETH_INFO_MAX,\n\t.get_link_net\t= veth_get_link_net,\n\t.get_num_tx_queues\t= veth_get_num_queues,\n\t.get_num_rx_queues\t= veth_get_num_queues,\n};\n```\n\n从 `kind` 到 `setup` 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 `veth_newlink`,`veth_dellink`，但二者的执行逻辑相关，所以只看其中一个。 \n\n首先是 `veth_newlink`, 不过他的实现较长，只能抓取一部分关键拆分开来看：\n\n```c\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n    ...\n    // 由于虚拟网络设备对是由两个网络设备组成,\n    // dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer\n    // 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer \n\tpeer = rtnl_create_link(net, ifname, name_assign_type,\n\t\t\t\t&veth_link_ops, tbp, extack);\n\terr = register_netdevice(peer);\n    ...\n    // 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去\n\terr = register_netdevice(dev);\n\n    ...\n    // 把 peer 和 dev 关联到一起\n\tpriv = netdev_priv(dev);               // 获取 dev 的私有数据部分\n\trcu_assign_pointer(priv->peer, peer);  // 将其 peer 字段指向 dev\n\terr = veth_init_queues(dev, tb);\n\tpriv = netdev_priv(peer);              // 获取 peer 的私有数据部分\n\trcu_assign_pointer(priv->peer, dev);   // 将其 peer 字段指向 dev\n    ...\n\terr = veth_init_queues(peer, tb);\n    \n    // 添加 XDP 访问支持 --> veth 在内核运行流程中接近网卡\n    ...\n\t/* update XDP supported features */\n\tveth_set_xdp_features(dev);\n\tveth_set_xdp_features(peer);\n    ...\n}\n```\n\n在`veth_newlink`当中通过**`register_netdevice`** 注册了两个网络虚拟设备： `peer` 和 `dev`，并通过让 `dev` 的 peer 指针指向创建的 peer，让`peer` 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。\n\n创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 `veth_setup`,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中\n\n```C\nstatic void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n    ...\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->xdp_metadata_ops = &veth_xdp_metadata_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n    ...\n}\n```\n\n可以看到是 veth 对象的操作列表包含三类：`veth_netdev_ops`,`veth_xdp_metadata_ops`,`veth_ethtool_ops`, 具体的列表如下：\n\nnet_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。\n\n从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。\n\n```C\nstatic const struct net_device_ops veth_netdev_ops = {\n\t.ndo_init            = veth_dev_init,\n\t.ndo_open            = veth_open,\n\t.ndo_stop            = veth_close,\n\t.ndo_start_xmit      = veth_xmit,\n\t.ndo_get_stats64     = veth_get_stats64,\n\t.ndo_set_rx_mode     = veth_set_multicast_list,\n\t.ndo_set_mac_address = eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= veth_poll_controller,\n#endif\n\t.ndo_get_iflink\t\t= veth_get_iflink,\n\t.ndo_fix_features\t= veth_fix_features,\n\t.ndo_set_features\t= veth_set_features,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,\n\t.ndo_bpf\t\t= veth_xdp,\n\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,\n\t.ndo_get_peer_dev\t= veth_peer_dev,\n};\n```\n\n这些函数的具体作用如下整理：\n\n- `ndo_init`: 该函数指向 `veth_dev_init`，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。\n\n- `ndo_open`: 该函数指向 `veth_open`，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。\n- `ndo_stop`：该函数指向 `veth_close`，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。\n- ==`ndo_start_xmit`：该函数指向 `veth_xmit`，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==\n- `ndo_get_stats64`：该函数指向 `veth_get_stats64`，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。\n- `ndo_set_rx_mode`：该函数指向 `veth_set_multicast_list`，由驱动程序实现，用于设置网络设备接收模式。\n- `ndo_set_mac_address`：该函数指向 `eth_mac_addr`，用于设置虚拟网络设备的MAC地址。\n- `ndo_poll_controller`：该函数指向 `veth_poll_controller`，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包\n- `ndo_get_iflink`：该函数指向 `veth_get_iflink`，用于获取虚拟网络设备的网络接口索引号。\n- `ndo_fix_features`：该函数指向 `veth_fix_features`，用于设置虚拟网络设备的特性参数；\n- `ndo_set_features`：该函数指向 `veth_set_features`，用于修改或更新虚拟网络设备已经打开的特性参数。\n- `ndo_features_check`：该函数指向 `passthru_features_check`，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。\n- `ndo_set_rx_headroom`: 该函数指向 `veth_set_rx_headroom`，用于设置虚拟网络设备中下行数据帧包头部的大小。\n- `ndo_bpf`：该函数指向 `veth_xdp`，用于添加eBPF扩展程序入口并进行初始化。\n- `ndo_xdp_xmit`: 该函数指向 `veth_ndo_xdp_xmit`，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。\n- `ndo_get_peer_dev`: 该函数指向 `veth_peer_dev`，用于获取与虚拟网络设备配对的网络设备。 \n\n`ethtool_ops`结构则代表了与`ethtool`工具相关的网络设备操作函数集合。`ethtool`用于获取和设置与`ethtool`兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。\n\n``` C\nstatic const struct ethtool_ops veth_ethtool_ops = {\n\t.get_drvinfo\t\t= veth_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= veth_get_strings,\n\t.get_sset_count\t\t= veth_get_sset_count,\n\t.get_ethtool_stats\t= veth_get_ethtool_stats,\n\t.get_link_ksettings\t= veth_get_link_ksettings,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_channels\t\t= veth_get_channels,\n\t.set_channels\t\t= veth_set_channels,\n};\n```\n\n`xdp_metadata_ops`结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。\n\n```c\nstatic const struct xdp_metadata_ops veth_xdp_metadata_ops = {\n\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,\n\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,\n};\n```\n\n- `xmo_rx_timestamp` ： 该函数指针指向 `veth_xdp_rx_timestamp` 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。\n\n- `xmo_rx_hash`：该函数指针指向 `veth_xdp_rx_hash`，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。\n\n在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。`xdp_metadata_ops` 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。\n\n到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 `net_device` 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 `ndo_start_xmit`函数，在指定了对端之后，数据包发送会存入 skb 并插入 `softnet_data->input_pkt_queue`中，出发软中断，接下来就是对称一般的内核接收过程。\n\n---\n\n## 网桥的连接和传输\n\nveth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。\n\n这样就需要解决单节点大量容器之间的网络互连问题。\n\n参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。\n\n如何使用 bridge 连接不同的网络空间呢？[Introduction to Linux interfaces for virtual networking | Red Hat Developer](https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device)，[Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community](https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a)  等文章也有详尽阐述，不再复述。\n\n其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。\n\n为了验证这一点，深入来看 bridge 的内核实现\n\n从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。\n\n从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。\n\n在这个过程中，bridge 输入数据包处理工作流程在 `/net/bridge/br_input.c` 中 `br_handle_frame_finish`函数里\n\n```c\nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n    // 获取 veth 所连接的网桥端口以及 bridge 设备\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n    // 创建转发表对象\n\tstruct net_bridge_fdb_entry *dst = NULL;\n    \n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mdb_entry *mdst;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge *br;\n\tbr = p->br;\n    \n    // 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)->h_source\n\tbr_fdb_update(br, p, eth_hdr(skb)->h_source,vid, BIT(BR_FDB_LOCKED));\t\n\tdst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);\n    \n    // 转发\n\tif (dst) {\n\t\tbr_forward(dst->dst, skb, local_rcv, false);\n    // 本机访问\n\tif (local_rcv)\n\t\treturn br_pass_frame_up(skb);\n}\n```\n\n其中查找和转发使用的地址是eth_hdr(skb)->h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。\n\n总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。\n\n其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。\n\n可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。\n\n---\n\n","source":"_posts/2024/04/cni-pod.md","raw":"---\ntitle: CNI 与  Pod 容器网络—— Linux 网络\ndate: 2024-04-11 22:17:51\ntags: ospp, cni, Linux\ncategories: EdgeMesh\ncatalog: true\n---\n\n# CNI 与  Pod 容器网络—— Linux 网络\n\n> Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? \n>\n> 如何保障 Pod IP 在整个集群当中的唯一性？\n>\n> 容器流量如何在所给的IP之间相互转发？\n\n---\n\n## 从 namespace 开始\n\nnamespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：\n\n``` bash\n       Linux provides the following namespaces:\n\n       Namespace   Constant          Isolates\n       Cgroup      CLONE_NEWCGROUP   Cgroup root directory\n       IPC         CLONE_NEWIPC      System V IPC, POSIX message queues\n       Network     CLONE_NEWNET      Network devices, stacks, ports, etc.\n       Mount       CLONE_NEWNS       Mount points\n       PID         CLONE_NEWPID      Process IDs\n       User        CLONE_NEWUSER     User and group IDs\n       UTS         CLONE_NEWUTS      Hostname and NIS domain name\n```\n\n其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。\n\n在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 **netns** 执行对 networkname space  的各项增删改查。\n\n依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？\n\n---\n\n## veth 的创建和连接\n\n首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过` ip link add veth0 type veth peer name veth1` 等指令来创建管理这些虚拟网卡，eg ：[从docker0开始](https://morningspace.github.io/tech/k8s-net-docker0/) ，[Deep dive into Linux Networking and Docker | Medium](https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72) 等文章就有讲到其作用和类似操作，不再复述。\n\n但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：[veth(4) - Linux manual page (man7.org)](https://man7.org/linux/man-pages/man4/veth.4.html)，[linux/veth.c at master · torvalds/linux (github.com)](https://github.com/torvalds/linux/blob/master/drivers/net/veth.c)\n\nveth的相关源码位于 `drivers/net/veth.c`中，其中的初始化入口是`veth_init`\n\n``` c\nstatic __init int veth_init(void)\n{\n\treturn rtnl_link_register(&veth_link_ops);\n}\n```\n\n初始化函数注册了`veth_link_ops`(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:\n\n```c\nstatic struct rtnl_link_ops veth_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct veth_priv),\n\t.setup\t\t= veth_setup,\n\t.validate\t= veth_validate,\n\t.newlink\t= veth_newlink,\n\t.dellink\t= veth_dellink,\n\t.policy\t\t= veth_policy,\n\t.maxtype\t= VETH_INFO_MAX,\n\t.get_link_net\t= veth_get_link_net,\n\t.get_num_tx_queues\t= veth_get_num_queues,\n\t.get_num_rx_queues\t= veth_get_num_queues,\n};\n```\n\n从 `kind` 到 `setup` 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 `veth_newlink`,`veth_dellink`，但二者的执行逻辑相关，所以只看其中一个。 \n\n首先是 `veth_newlink`, 不过他的实现较长，只能抓取一部分关键拆分开来看：\n\n```c\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n    ...\n    // 由于虚拟网络设备对是由两个网络设备组成,\n    // dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer\n    // 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer \n\tpeer = rtnl_create_link(net, ifname, name_assign_type,\n\t\t\t\t&veth_link_ops, tbp, extack);\n\terr = register_netdevice(peer);\n    ...\n    // 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去\n\terr = register_netdevice(dev);\n\n    ...\n    // 把 peer 和 dev 关联到一起\n\tpriv = netdev_priv(dev);               // 获取 dev 的私有数据部分\n\trcu_assign_pointer(priv->peer, peer);  // 将其 peer 字段指向 dev\n\terr = veth_init_queues(dev, tb);\n\tpriv = netdev_priv(peer);              // 获取 peer 的私有数据部分\n\trcu_assign_pointer(priv->peer, dev);   // 将其 peer 字段指向 dev\n    ...\n\terr = veth_init_queues(peer, tb);\n    \n    // 添加 XDP 访问支持 --> veth 在内核运行流程中接近网卡\n    ...\n\t/* update XDP supported features */\n\tveth_set_xdp_features(dev);\n\tveth_set_xdp_features(peer);\n    ...\n}\n```\n\n在`veth_newlink`当中通过**`register_netdevice`** 注册了两个网络虚拟设备： `peer` 和 `dev`，并通过让 `dev` 的 peer 指针指向创建的 peer，让`peer` 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。\n\n创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 `veth_setup`,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中\n\n```C\nstatic void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n    ...\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->xdp_metadata_ops = &veth_xdp_metadata_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n    ...\n}\n```\n\n可以看到是 veth 对象的操作列表包含三类：`veth_netdev_ops`,`veth_xdp_metadata_ops`,`veth_ethtool_ops`, 具体的列表如下：\n\nnet_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。\n\n从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。\n\n```C\nstatic const struct net_device_ops veth_netdev_ops = {\n\t.ndo_init            = veth_dev_init,\n\t.ndo_open            = veth_open,\n\t.ndo_stop            = veth_close,\n\t.ndo_start_xmit      = veth_xmit,\n\t.ndo_get_stats64     = veth_get_stats64,\n\t.ndo_set_rx_mode     = veth_set_multicast_list,\n\t.ndo_set_mac_address = eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= veth_poll_controller,\n#endif\n\t.ndo_get_iflink\t\t= veth_get_iflink,\n\t.ndo_fix_features\t= veth_fix_features,\n\t.ndo_set_features\t= veth_set_features,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,\n\t.ndo_bpf\t\t= veth_xdp,\n\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,\n\t.ndo_get_peer_dev\t= veth_peer_dev,\n};\n```\n\n这些函数的具体作用如下整理：\n\n- `ndo_init`: 该函数指向 `veth_dev_init`，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。\n\n- `ndo_open`: 该函数指向 `veth_open`，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。\n- `ndo_stop`：该函数指向 `veth_close`，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。\n- ==`ndo_start_xmit`：该函数指向 `veth_xmit`，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==\n- `ndo_get_stats64`：该函数指向 `veth_get_stats64`，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。\n- `ndo_set_rx_mode`：该函数指向 `veth_set_multicast_list`，由驱动程序实现，用于设置网络设备接收模式。\n- `ndo_set_mac_address`：该函数指向 `eth_mac_addr`，用于设置虚拟网络设备的MAC地址。\n- `ndo_poll_controller`：该函数指向 `veth_poll_controller`，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包\n- `ndo_get_iflink`：该函数指向 `veth_get_iflink`，用于获取虚拟网络设备的网络接口索引号。\n- `ndo_fix_features`：该函数指向 `veth_fix_features`，用于设置虚拟网络设备的特性参数；\n- `ndo_set_features`：该函数指向 `veth_set_features`，用于修改或更新虚拟网络设备已经打开的特性参数。\n- `ndo_features_check`：该函数指向 `passthru_features_check`，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。\n- `ndo_set_rx_headroom`: 该函数指向 `veth_set_rx_headroom`，用于设置虚拟网络设备中下行数据帧包头部的大小。\n- `ndo_bpf`：该函数指向 `veth_xdp`，用于添加eBPF扩展程序入口并进行初始化。\n- `ndo_xdp_xmit`: 该函数指向 `veth_ndo_xdp_xmit`，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。\n- `ndo_get_peer_dev`: 该函数指向 `veth_peer_dev`，用于获取与虚拟网络设备配对的网络设备。 \n\n`ethtool_ops`结构则代表了与`ethtool`工具相关的网络设备操作函数集合。`ethtool`用于获取和设置与`ethtool`兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。\n\n``` C\nstatic const struct ethtool_ops veth_ethtool_ops = {\n\t.get_drvinfo\t\t= veth_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= veth_get_strings,\n\t.get_sset_count\t\t= veth_get_sset_count,\n\t.get_ethtool_stats\t= veth_get_ethtool_stats,\n\t.get_link_ksettings\t= veth_get_link_ksettings,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_channels\t\t= veth_get_channels,\n\t.set_channels\t\t= veth_set_channels,\n};\n```\n\n`xdp_metadata_ops`结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。\n\n```c\nstatic const struct xdp_metadata_ops veth_xdp_metadata_ops = {\n\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,\n\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,\n};\n```\n\n- `xmo_rx_timestamp` ： 该函数指针指向 `veth_xdp_rx_timestamp` 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。\n\n- `xmo_rx_hash`：该函数指针指向 `veth_xdp_rx_hash`，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。\n\n在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。`xdp_metadata_ops` 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。\n\n到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 `net_device` 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 `ndo_start_xmit`函数，在指定了对端之后，数据包发送会存入 skb 并插入 `softnet_data->input_pkt_queue`中，出发软中断，接下来就是对称一般的内核接收过程。\n\n---\n\n## 网桥的连接和传输\n\nveth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。\n\n这样就需要解决单节点大量容器之间的网络互连问题。\n\n参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。\n\n如何使用 bridge 连接不同的网络空间呢？[Introduction to Linux interfaces for virtual networking | Red Hat Developer](https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device)，[Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community](https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a)  等文章也有详尽阐述，不再复述。\n\n其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。\n\n为了验证这一点，深入来看 bridge 的内核实现\n\n从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。\n\n从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。\n\n在这个过程中，bridge 输入数据包处理工作流程在 `/net/bridge/br_input.c` 中 `br_handle_frame_finish`函数里\n\n```c\nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n    // 获取 veth 所连接的网桥端口以及 bridge 设备\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n    // 创建转发表对象\n\tstruct net_bridge_fdb_entry *dst = NULL;\n    \n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mdb_entry *mdst;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge *br;\n\tbr = p->br;\n    \n    // 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)->h_source\n\tbr_fdb_update(br, p, eth_hdr(skb)->h_source,vid, BIT(BR_FDB_LOCKED));\t\n\tdst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);\n    \n    // 转发\n\tif (dst) {\n\t\tbr_forward(dst->dst, skb, local_rcv, false);\n    // 本机访问\n\tif (local_rcv)\n\t\treturn br_pass_frame_up(skb);\n}\n```\n\n其中查找和转发使用的地址是eth_hdr(skb)->h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。\n\n总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。\n\n其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。\n\n可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。\n\n---\n\n","slug":"cni-pod","published":1,"updated":"2024-04-11T14:20:35.467Z","_id":"cluvbsnop000082peatwdaki3","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"CNI-与-Pod-容器网络——-Linux-网络\"><a href=\"#CNI-与-Pod-容器网络——-Linux-网络\" class=\"headerlink\" title=\"CNI 与  Pod 容器网络—— Linux 网络\"></a>CNI 与  Pod 容器网络—— Linux 网络</h1><blockquote>\n<p>Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? </p>\n<p>如何保障 Pod IP 在整个集群当中的唯一性？</p>\n<p>容器流量如何在所给的IP之间相互转发？</p>\n</blockquote>\n<hr>\n<h2 id=\"从-namespace-开始\"><a href=\"#从-namespace-开始\" class=\"headerlink\" title=\"从 namespace 开始\"></a>从 namespace 开始</h2><p>namespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux provides the following namespaces:</span><br><span class=\"line\"></span><br><span class=\"line\">Namespace   Constant          Isolates</span><br><span class=\"line\">Cgroup      CLONE_NEWCGROUP   Cgroup root directory</span><br><span class=\"line\">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues</span><br><span class=\"line\">Network     CLONE_NEWNET      Network devices, stacks, ports, etc.</span><br><span class=\"line\">Mount       CLONE_NEWNS       Mount points</span><br><span class=\"line\">PID         CLONE_NEWPID      Process IDs</span><br><span class=\"line\">User        CLONE_NEWUSER     User and group IDs</span><br><span class=\"line\">UTS         CLONE_NEWUTS      Hostname and NIS domain name</span><br></pre></td></tr></table></figure>\n\n<p>其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。</p>\n<p>在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 <strong>netns</strong> 执行对 networkname space  的各项增删改查。</p>\n<p>依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？</p>\n<hr>\n<h2 id=\"veth-的创建和连接\"><a href=\"#veth-的创建和连接\" class=\"headerlink\" title=\"veth 的创建和连接\"></a>veth 的创建和连接</h2><p>首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过<code> ip link add veth0 type veth peer name veth1</code> 等指令来创建管理这些虚拟网卡，eg ：<a href=\"https://morningspace.github.io/tech/k8s-net-docker0/\">从docker0开始</a> ，<a href=\"https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72\">Deep dive into Linux Networking and Docker | Medium</a> 等文章就有讲到其作用和类似操作，不再复述。</p>\n<p>但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：<a href=\"https://man7.org/linux/man-pages/man4/veth.4.html\">veth(4) - Linux manual page (man7.org)</a>，<a href=\"https://github.com/torvalds/linux/blob/master/drivers/net/veth.c\">linux&#x2F;veth.c at master · torvalds&#x2F;linux (github.com)</a></p>\n<p>veth的相关源码位于 <code>drivers/net/veth.c</code>中，其中的初始化入口是<code>veth_init</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">veth_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rtnl_link_register(&amp;veth_link_ops);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化函数注册了<code>veth_link_ops</code>(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rtnl_link_ops</span> <span class=\"title\">veth_link_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.kind\t\t= DRV_NAME,</span><br><span class=\"line\">\t.priv_size\t= <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> veth_priv),</span><br><span class=\"line\">\t.setup\t\t= veth_setup,</span><br><span class=\"line\">\t.validate\t= veth_validate,</span><br><span class=\"line\">\t.newlink\t= veth_newlink,</span><br><span class=\"line\">\t.dellink\t= veth_dellink,</span><br><span class=\"line\">\t.policy\t\t= veth_policy,</span><br><span class=\"line\">\t.maxtype\t= VETH_INFO_MAX,</span><br><span class=\"line\">\t.get_link_net\t= veth_get_link_net,</span><br><span class=\"line\">\t.get_num_tx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">\t.get_num_rx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>从 <code>kind</code> 到 <code>setup</code> 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 <code>veth_newlink</code>,<code>veth_dellink</code>，但二者的执行逻辑相关，所以只看其中一个。 </p>\n<p>首先是 <code>veth_newlink</code>, 不过他的实现较长，只能抓取一部分关键拆分开来看：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">veth_newlink</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *src_net, <span class=\"keyword\">struct</span> net_device *dev,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> nlattr *tb[], <span class=\"keyword\">struct</span> nlattr *data[],</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> netlink_ext_ack *extack)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 由于虚拟网络设备对是由两个网络设备组成,</span></span><br><span class=\"line\">    <span class=\"comment\">// dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer</span></span><br><span class=\"line\">    <span class=\"comment\">// 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer </span></span><br><span class=\"line\">\tpeer = rtnl_create_link(net, ifname, name_assign_type,</span><br><span class=\"line\">\t\t\t\t&amp;veth_link_ops, tbp, extack);</span><br><span class=\"line\">\terr = register_netdevice(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去</span></span><br><span class=\"line\">\terr = register_netdevice(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 把 peer 和 dev 关联到一起</span></span><br><span class=\"line\">\tpriv = netdev_priv(dev);               <span class=\"comment\">// 获取 dev 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, peer);  <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">\terr = veth_init_queues(dev, tb);</span><br><span class=\"line\">\tpriv = netdev_priv(peer);              <span class=\"comment\">// 获取 peer 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, dev);   <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\terr = veth_init_queues(peer, tb);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加 XDP 访问支持 --&gt; veth 在内核运行流程中接近网卡</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">/* update XDP supported features */</span></span><br><span class=\"line\">\tveth_set_xdp_features(dev);</span><br><span class=\"line\">\tveth_set_xdp_features(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>veth_newlink</code>当中通过**<code>register_netdevice</code>** 注册了两个网络虚拟设备： <code>peer</code> 和 <code>dev</code>，并通过让 <code>dev</code> 的 peer 指针指向创建的 peer，让<code>peer</code> 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。</p>\n<p>创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 <code>veth_setup</code>,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">veth_setup</span><span class=\"params\">(<span class=\"keyword\">struct</span> net_device *dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tether_setup(dev);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tdev-&gt;netdev_ops = &amp;veth_netdev_ops;</span><br><span class=\"line\">\tdev-&gt;xdp_metadata_ops = &amp;veth_xdp_metadata_ops;</span><br><span class=\"line\">\tdev-&gt;ethtool_ops = &amp;veth_ethtool_ops;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到是 veth 对象的操作列表包含三类：<code>veth_netdev_ops</code>,<code>veth_xdp_metadata_ops</code>,<code>veth_ethtool_ops</code>, 具体的列表如下：</p>\n<p>net_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。</p>\n<p>从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device_ops</span> <span class=\"title\">veth_netdev_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.ndo_init            = veth_dev_init,</span><br><span class=\"line\">\t.ndo_open            = veth_open,</span><br><span class=\"line\">\t.ndo_stop            = veth_close,</span><br><span class=\"line\">\t.ndo_start_xmit      = veth_xmit,</span><br><span class=\"line\">\t.ndo_get_stats64     = veth_get_stats64,</span><br><span class=\"line\">\t.ndo_set_rx_mode     = veth_set_multicast_list,</span><br><span class=\"line\">\t.ndo_set_mac_address = eth_mac_addr,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class=\"line\">\t.ndo_poll_controller\t= veth_poll_controller,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t.ndo_get_iflink\t\t= veth_get_iflink,</span><br><span class=\"line\">\t.ndo_fix_features\t= veth_fix_features,</span><br><span class=\"line\">\t.ndo_set_features\t= veth_set_features,</span><br><span class=\"line\">\t.ndo_features_check\t= passthru_features_check,</span><br><span class=\"line\">\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,</span><br><span class=\"line\">\t.ndo_bpf\t\t= veth_xdp,</span><br><span class=\"line\">\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,</span><br><span class=\"line\">\t.ndo_get_peer_dev\t= veth_peer_dev,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这些函数的具体作用如下整理：</p>\n<ul>\n<li><p><code>ndo_init</code>: 该函数指向 <code>veth_dev_init</code>，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。</p>\n</li>\n<li><p><code>ndo_open</code>: 该函数指向 <code>veth_open</code>，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。</p>\n</li>\n<li><p><code>ndo_stop</code>：该函数指向 <code>veth_close</code>，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。</p>\n</li>\n<li><p>&#x3D;&#x3D;<code>ndo_start_xmit</code>：该函数指向 <code>veth_xmit</code>，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。&#x3D;&#x3D;</p>\n</li>\n<li><p><code>ndo_get_stats64</code>：该函数指向 <code>veth_get_stats64</code>，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。</p>\n</li>\n<li><p><code>ndo_set_rx_mode</code>：该函数指向 <code>veth_set_multicast_list</code>，由驱动程序实现，用于设置网络设备接收模式。</p>\n</li>\n<li><p><code>ndo_set_mac_address</code>：该函数指向 <code>eth_mac_addr</code>，用于设置虚拟网络设备的MAC地址。</p>\n</li>\n<li><p><code>ndo_poll_controller</code>：该函数指向 <code>veth_poll_controller</code>，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包</p>\n</li>\n<li><p><code>ndo_get_iflink</code>：该函数指向 <code>veth_get_iflink</code>，用于获取虚拟网络设备的网络接口索引号。</p>\n</li>\n<li><p><code>ndo_fix_features</code>：该函数指向 <code>veth_fix_features</code>，用于设置虚拟网络设备的特性参数；</p>\n</li>\n<li><p><code>ndo_set_features</code>：该函数指向 <code>veth_set_features</code>，用于修改或更新虚拟网络设备已经打开的特性参数。</p>\n</li>\n<li><p><code>ndo_features_check</code>：该函数指向 <code>passthru_features_check</code>，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。</p>\n</li>\n<li><p><code>ndo_set_rx_headroom</code>: 该函数指向 <code>veth_set_rx_headroom</code>，用于设置虚拟网络设备中下行数据帧包头部的大小。</p>\n</li>\n<li><p><code>ndo_bpf</code>：该函数指向 <code>veth_xdp</code>，用于添加eBPF扩展程序入口并进行初始化。</p>\n</li>\n<li><p><code>ndo_xdp_xmit</code>: 该函数指向 <code>veth_ndo_xdp_xmit</code>，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。</p>\n</li>\n<li><p><code>ndo_get_peer_dev</code>: 该函数指向 <code>veth_peer_dev</code>，用于获取与虚拟网络设备配对的网络设备。</p>\n</li>\n</ul>\n<p><code>ethtool_ops</code>结构则代表了与<code>ethtool</code>工具相关的网络设备操作函数集合。<code>ethtool</code>用于获取和设置与<code>ethtool</code>兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ethtool_ops</span> <span class=\"title\">veth_ethtool_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.get_drvinfo\t\t= veth_get_drvinfo,</span><br><span class=\"line\">\t.get_link\t\t= ethtool_op_get_link,</span><br><span class=\"line\">\t.get_strings\t\t= veth_get_strings,</span><br><span class=\"line\">\t.get_sset_count\t\t= veth_get_sset_count,</span><br><span class=\"line\">\t.get_ethtool_stats\t= veth_get_ethtool_stats,</span><br><span class=\"line\">\t.get_link_ksettings\t= veth_get_link_ksettings,</span><br><span class=\"line\">\t.get_ts_info\t\t= ethtool_op_get_ts_info,</span><br><span class=\"line\">\t.get_channels\t\t= veth_get_channels,</span><br><span class=\"line\">\t.set_channels\t\t= veth_set_channels,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>xdp_metadata_ops</code>结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">xdp_metadata_ops</span> <span class=\"title\">veth_xdp_metadata_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,</span><br><span class=\"line\">\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>xmo_rx_timestamp</code> ： 该函数指针指向 <code>veth_xdp_rx_timestamp</code> 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。</p>\n</li>\n<li><p><code>xmo_rx_hash</code>：该函数指针指向 <code>veth_xdp_rx_hash</code>，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。</p>\n</li>\n</ul>\n<p>在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。<code>xdp_metadata_ops</code> 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。</p>\n<p>到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 <code>net_device</code> 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 <code>ndo_start_xmit</code>函数，在指定了对端之后，数据包发送会存入 skb 并插入 <code>softnet_data-&gt;input_pkt_queue</code>中，出发软中断，接下来就是对称一般的内核接收过程。</p>\n<hr>\n<h2 id=\"网桥的连接和传输\"><a href=\"#网桥的连接和传输\" class=\"headerlink\" title=\"网桥的连接和传输\"></a>网桥的连接和传输</h2><p>veth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。</p>\n<p>这样就需要解决单节点大量容器之间的网络互连问题。</p>\n<p>参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。</p>\n<p>如何使用 bridge 连接不同的网络空间呢？<a href=\"https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device\">Introduction to Linux interfaces for virtual networking | Red Hat Developer</a>，<a href=\"https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a\">Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community</a>  等文章也有详尽阐述，不再复述。</p>\n<p>其中要关注的点是： bridge 的工作源码都是在 &#x2F;net&#x2F;core&#x2F;dev.c 或者是 &#x2F;net&#x2F;bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。</p>\n<p>为了验证这一点，深入来看 bridge 的内核实现</p>\n<p>从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。</p>\n<p>从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。</p>\n<p>在这个过程中，bridge 输入数据包处理工作流程在 <code>/net/bridge/br_input.c</code> 中 <code>br_handle_frame_finish</code>函数里</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">br_handle_frame_finish</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *net, <span class=\"keyword\">struct</span> sock *sk, <span class=\"keyword\">struct</span> sk_buff *skb)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 veth 所连接的网桥端口以及 bridge 设备</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_port</span> *<span class=\"title\">p</span> =</span> br_port_get_rcu(skb-&gt;dev);</span><br><span class=\"line\">    <span class=\"comment\">// 创建转发表对象</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_fdb_entry</span> *<span class=\"title\">dst</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mcast_port</span> *<span class=\"title\">pmctx</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mdb_entry</span> *<span class=\"title\">mdst</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_vlan</span> *<span class=\"title\">vlan</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge</span> *<span class=\"title\">br</span>;</span></span><br><span class=\"line\">\tbr = p-&gt;br;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)-&gt;h_source</span></span><br><span class=\"line\">\tbr_fdb_update(br, p, eth_hdr(skb)-&gt;h_source,vid, BIT(BR_FDB_LOCKED));\t</span><br><span class=\"line\">\tdst = br_fdb_find_rcu(br, eth_hdr(skb)-&gt;h_dest, vid);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 转发</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dst) &#123;</span><br><span class=\"line\">\t\tbr_forward(dst-&gt;dst, skb, local_rcv, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 本机访问</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (local_rcv)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> br_pass_frame_up(skb);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中查找和转发使用的地址是eth_hdr(skb)-&gt;h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。</p>\n<p>总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。</p>\n<p>其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。</p>\n<p>可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。</p>\n<hr>\n","cover":false,"excerpt":"","more":"<h1 id=\"CNI-与-Pod-容器网络——-Linux-网络\"><a href=\"#CNI-与-Pod-容器网络——-Linux-网络\" class=\"headerlink\" title=\"CNI 与  Pod 容器网络—— Linux 网络\"></a>CNI 与  Pod 容器网络—— Linux 网络</h1><blockquote>\n<p>Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? </p>\n<p>如何保障 Pod IP 在整个集群当中的唯一性？</p>\n<p>容器流量如何在所给的IP之间相互转发？</p>\n</blockquote>\n<hr>\n<h2 id=\"从-namespace-开始\"><a href=\"#从-namespace-开始\" class=\"headerlink\" title=\"从 namespace 开始\"></a>从 namespace 开始</h2><p>namespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux provides the following namespaces:</span><br><span class=\"line\"></span><br><span class=\"line\">Namespace   Constant          Isolates</span><br><span class=\"line\">Cgroup      CLONE_NEWCGROUP   Cgroup root directory</span><br><span class=\"line\">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues</span><br><span class=\"line\">Network     CLONE_NEWNET      Network devices, stacks, ports, etc.</span><br><span class=\"line\">Mount       CLONE_NEWNS       Mount points</span><br><span class=\"line\">PID         CLONE_NEWPID      Process IDs</span><br><span class=\"line\">User        CLONE_NEWUSER     User and group IDs</span><br><span class=\"line\">UTS         CLONE_NEWUTS      Hostname and NIS domain name</span><br></pre></td></tr></table></figure>\n\n<p>其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。</p>\n<p>在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 <strong>netns</strong> 执行对 networkname space  的各项增删改查。</p>\n<p>依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？</p>\n<hr>\n<h2 id=\"veth-的创建和连接\"><a href=\"#veth-的创建和连接\" class=\"headerlink\" title=\"veth 的创建和连接\"></a>veth 的创建和连接</h2><p>首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过<code> ip link add veth0 type veth peer name veth1</code> 等指令来创建管理这些虚拟网卡，eg ：<a href=\"https://morningspace.github.io/tech/k8s-net-docker0/\">从docker0开始</a> ，<a href=\"https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72\">Deep dive into Linux Networking and Docker | Medium</a> 等文章就有讲到其作用和类似操作，不再复述。</p>\n<p>但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：<a href=\"https://man7.org/linux/man-pages/man4/veth.4.html\">veth(4) - Linux manual page (man7.org)</a>，<a href=\"https://github.com/torvalds/linux/blob/master/drivers/net/veth.c\">linux&#x2F;veth.c at master · torvalds&#x2F;linux (github.com)</a></p>\n<p>veth的相关源码位于 <code>drivers/net/veth.c</code>中，其中的初始化入口是<code>veth_init</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">veth_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rtnl_link_register(&amp;veth_link_ops);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化函数注册了<code>veth_link_ops</code>(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rtnl_link_ops</span> <span class=\"title\">veth_link_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.kind\t\t= DRV_NAME,</span><br><span class=\"line\">\t.priv_size\t= <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> veth_priv),</span><br><span class=\"line\">\t.setup\t\t= veth_setup,</span><br><span class=\"line\">\t.validate\t= veth_validate,</span><br><span class=\"line\">\t.newlink\t= veth_newlink,</span><br><span class=\"line\">\t.dellink\t= veth_dellink,</span><br><span class=\"line\">\t.policy\t\t= veth_policy,</span><br><span class=\"line\">\t.maxtype\t= VETH_INFO_MAX,</span><br><span class=\"line\">\t.get_link_net\t= veth_get_link_net,</span><br><span class=\"line\">\t.get_num_tx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">\t.get_num_rx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>从 <code>kind</code> 到 <code>setup</code> 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 <code>veth_newlink</code>,<code>veth_dellink</code>，但二者的执行逻辑相关，所以只看其中一个。 </p>\n<p>首先是 <code>veth_newlink</code>, 不过他的实现较长，只能抓取一部分关键拆分开来看：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">veth_newlink</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *src_net, <span class=\"keyword\">struct</span> net_device *dev,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> nlattr *tb[], <span class=\"keyword\">struct</span> nlattr *data[],</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> netlink_ext_ack *extack)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 由于虚拟网络设备对是由两个网络设备组成,</span></span><br><span class=\"line\">    <span class=\"comment\">// dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer</span></span><br><span class=\"line\">    <span class=\"comment\">// 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer </span></span><br><span class=\"line\">\tpeer = rtnl_create_link(net, ifname, name_assign_type,</span><br><span class=\"line\">\t\t\t\t&amp;veth_link_ops, tbp, extack);</span><br><span class=\"line\">\terr = register_netdevice(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去</span></span><br><span class=\"line\">\terr = register_netdevice(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 把 peer 和 dev 关联到一起</span></span><br><span class=\"line\">\tpriv = netdev_priv(dev);               <span class=\"comment\">// 获取 dev 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, peer);  <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">\terr = veth_init_queues(dev, tb);</span><br><span class=\"line\">\tpriv = netdev_priv(peer);              <span class=\"comment\">// 获取 peer 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, dev);   <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\terr = veth_init_queues(peer, tb);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加 XDP 访问支持 --&gt; veth 在内核运行流程中接近网卡</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">/* update XDP supported features */</span></span><br><span class=\"line\">\tveth_set_xdp_features(dev);</span><br><span class=\"line\">\tveth_set_xdp_features(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>veth_newlink</code>当中通过**<code>register_netdevice</code>** 注册了两个网络虚拟设备： <code>peer</code> 和 <code>dev</code>，并通过让 <code>dev</code> 的 peer 指针指向创建的 peer，让<code>peer</code> 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。</p>\n<p>创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 <code>veth_setup</code>,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">veth_setup</span><span class=\"params\">(<span class=\"keyword\">struct</span> net_device *dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tether_setup(dev);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tdev-&gt;netdev_ops = &amp;veth_netdev_ops;</span><br><span class=\"line\">\tdev-&gt;xdp_metadata_ops = &amp;veth_xdp_metadata_ops;</span><br><span class=\"line\">\tdev-&gt;ethtool_ops = &amp;veth_ethtool_ops;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到是 veth 对象的操作列表包含三类：<code>veth_netdev_ops</code>,<code>veth_xdp_metadata_ops</code>,<code>veth_ethtool_ops</code>, 具体的列表如下：</p>\n<p>net_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。</p>\n<p>从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device_ops</span> <span class=\"title\">veth_netdev_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.ndo_init            = veth_dev_init,</span><br><span class=\"line\">\t.ndo_open            = veth_open,</span><br><span class=\"line\">\t.ndo_stop            = veth_close,</span><br><span class=\"line\">\t.ndo_start_xmit      = veth_xmit,</span><br><span class=\"line\">\t.ndo_get_stats64     = veth_get_stats64,</span><br><span class=\"line\">\t.ndo_set_rx_mode     = veth_set_multicast_list,</span><br><span class=\"line\">\t.ndo_set_mac_address = eth_mac_addr,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class=\"line\">\t.ndo_poll_controller\t= veth_poll_controller,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t.ndo_get_iflink\t\t= veth_get_iflink,</span><br><span class=\"line\">\t.ndo_fix_features\t= veth_fix_features,</span><br><span class=\"line\">\t.ndo_set_features\t= veth_set_features,</span><br><span class=\"line\">\t.ndo_features_check\t= passthru_features_check,</span><br><span class=\"line\">\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,</span><br><span class=\"line\">\t.ndo_bpf\t\t= veth_xdp,</span><br><span class=\"line\">\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,</span><br><span class=\"line\">\t.ndo_get_peer_dev\t= veth_peer_dev,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这些函数的具体作用如下整理：</p>\n<ul>\n<li><p><code>ndo_init</code>: 该函数指向 <code>veth_dev_init</code>，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。</p>\n</li>\n<li><p><code>ndo_open</code>: 该函数指向 <code>veth_open</code>，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。</p>\n</li>\n<li><p><code>ndo_stop</code>：该函数指向 <code>veth_close</code>，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。</p>\n</li>\n<li><p>&#x3D;&#x3D;<code>ndo_start_xmit</code>：该函数指向 <code>veth_xmit</code>，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。&#x3D;&#x3D;</p>\n</li>\n<li><p><code>ndo_get_stats64</code>：该函数指向 <code>veth_get_stats64</code>，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。</p>\n</li>\n<li><p><code>ndo_set_rx_mode</code>：该函数指向 <code>veth_set_multicast_list</code>，由驱动程序实现，用于设置网络设备接收模式。</p>\n</li>\n<li><p><code>ndo_set_mac_address</code>：该函数指向 <code>eth_mac_addr</code>，用于设置虚拟网络设备的MAC地址。</p>\n</li>\n<li><p><code>ndo_poll_controller</code>：该函数指向 <code>veth_poll_controller</code>，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包</p>\n</li>\n<li><p><code>ndo_get_iflink</code>：该函数指向 <code>veth_get_iflink</code>，用于获取虚拟网络设备的网络接口索引号。</p>\n</li>\n<li><p><code>ndo_fix_features</code>：该函数指向 <code>veth_fix_features</code>，用于设置虚拟网络设备的特性参数；</p>\n</li>\n<li><p><code>ndo_set_features</code>：该函数指向 <code>veth_set_features</code>，用于修改或更新虚拟网络设备已经打开的特性参数。</p>\n</li>\n<li><p><code>ndo_features_check</code>：该函数指向 <code>passthru_features_check</code>，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。</p>\n</li>\n<li><p><code>ndo_set_rx_headroom</code>: 该函数指向 <code>veth_set_rx_headroom</code>，用于设置虚拟网络设备中下行数据帧包头部的大小。</p>\n</li>\n<li><p><code>ndo_bpf</code>：该函数指向 <code>veth_xdp</code>，用于添加eBPF扩展程序入口并进行初始化。</p>\n</li>\n<li><p><code>ndo_xdp_xmit</code>: 该函数指向 <code>veth_ndo_xdp_xmit</code>，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。</p>\n</li>\n<li><p><code>ndo_get_peer_dev</code>: 该函数指向 <code>veth_peer_dev</code>，用于获取与虚拟网络设备配对的网络设备。</p>\n</li>\n</ul>\n<p><code>ethtool_ops</code>结构则代表了与<code>ethtool</code>工具相关的网络设备操作函数集合。<code>ethtool</code>用于获取和设置与<code>ethtool</code>兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ethtool_ops</span> <span class=\"title\">veth_ethtool_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.get_drvinfo\t\t= veth_get_drvinfo,</span><br><span class=\"line\">\t.get_link\t\t= ethtool_op_get_link,</span><br><span class=\"line\">\t.get_strings\t\t= veth_get_strings,</span><br><span class=\"line\">\t.get_sset_count\t\t= veth_get_sset_count,</span><br><span class=\"line\">\t.get_ethtool_stats\t= veth_get_ethtool_stats,</span><br><span class=\"line\">\t.get_link_ksettings\t= veth_get_link_ksettings,</span><br><span class=\"line\">\t.get_ts_info\t\t= ethtool_op_get_ts_info,</span><br><span class=\"line\">\t.get_channels\t\t= veth_get_channels,</span><br><span class=\"line\">\t.set_channels\t\t= veth_set_channels,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>xdp_metadata_ops</code>结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">xdp_metadata_ops</span> <span class=\"title\">veth_xdp_metadata_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,</span><br><span class=\"line\">\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>xmo_rx_timestamp</code> ： 该函数指针指向 <code>veth_xdp_rx_timestamp</code> 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。</p>\n</li>\n<li><p><code>xmo_rx_hash</code>：该函数指针指向 <code>veth_xdp_rx_hash</code>，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。</p>\n</li>\n</ul>\n<p>在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。<code>xdp_metadata_ops</code> 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。</p>\n<p>到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 <code>net_device</code> 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 <code>ndo_start_xmit</code>函数，在指定了对端之后，数据包发送会存入 skb 并插入 <code>softnet_data-&gt;input_pkt_queue</code>中，出发软中断，接下来就是对称一般的内核接收过程。</p>\n<hr>\n<h2 id=\"网桥的连接和传输\"><a href=\"#网桥的连接和传输\" class=\"headerlink\" title=\"网桥的连接和传输\"></a>网桥的连接和传输</h2><p>veth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。</p>\n<p>这样就需要解决单节点大量容器之间的网络互连问题。</p>\n<p>参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。</p>\n<p>如何使用 bridge 连接不同的网络空间呢？<a href=\"https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device\">Introduction to Linux interfaces for virtual networking | Red Hat Developer</a>，<a href=\"https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a\">Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community</a>  等文章也有详尽阐述，不再复述。</p>\n<p>其中要关注的点是： bridge 的工作源码都是在 &#x2F;net&#x2F;core&#x2F;dev.c 或者是 &#x2F;net&#x2F;bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。</p>\n<p>为了验证这一点，深入来看 bridge 的内核实现</p>\n<p>从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。</p>\n<p>从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。</p>\n<p>在这个过程中，bridge 输入数据包处理工作流程在 <code>/net/bridge/br_input.c</code> 中 <code>br_handle_frame_finish</code>函数里</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">br_handle_frame_finish</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *net, <span class=\"keyword\">struct</span> sock *sk, <span class=\"keyword\">struct</span> sk_buff *skb)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 veth 所连接的网桥端口以及 bridge 设备</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_port</span> *<span class=\"title\">p</span> =</span> br_port_get_rcu(skb-&gt;dev);</span><br><span class=\"line\">    <span class=\"comment\">// 创建转发表对象</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_fdb_entry</span> *<span class=\"title\">dst</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mcast_port</span> *<span class=\"title\">pmctx</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mdb_entry</span> *<span class=\"title\">mdst</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_vlan</span> *<span class=\"title\">vlan</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge</span> *<span class=\"title\">br</span>;</span></span><br><span class=\"line\">\tbr = p-&gt;br;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)-&gt;h_source</span></span><br><span class=\"line\">\tbr_fdb_update(br, p, eth_hdr(skb)-&gt;h_source,vid, BIT(BR_FDB_LOCKED));\t</span><br><span class=\"line\">\tdst = br_fdb_find_rcu(br, eth_hdr(skb)-&gt;h_dest, vid);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 转发</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dst) &#123;</span><br><span class=\"line\">\t\tbr_forward(dst-&gt;dst, skb, local_rcv, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 本机访问</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (local_rcv)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> br_pass_frame_up(skb);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中查找和转发使用的地址是eth_hdr(skb)-&gt;h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。</p>\n<p>总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。</p>\n<p>其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。</p>\n<p>可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。</p>\n<hr>\n"},{"title":"CNI Plugins 调研","date":"2024-04-11T14:18:42.000Z","catalog":true,"_content":"# CNI Plugins 调研\n\n## 1. 通用 CNI 插件\n\n> 主要基于 [containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)](https://github.com/containernetworking/plugins) ，[CNI](https://www.cni.dev/plugins/current/)\n\n由CNI 官方社区维护的 CNI plugins 主要分为三类：\n\n* `Main: interface-creating`: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等\n* `IPAM: IP address allocation`:  地址管理插件，主要负责 IP 地址管理和分配\n* `Meta: other plugins`: 其他的功能插件\n\n\n\n### Main: interface-creating  主进程 CNI \n\n### [`bridge`](https://www.cni.dev/plugins/current/main/bridge/) \n\n​\t创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中\n\n### [`macvlan`](https://www.cni.dev/plugins/current/main/macvlan/)\n\n​\t创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址\n\n### [`ipvlan`](https://www.cni.dev/plugins/current/main/ipvlan/) \n\n​\t类似于 `macvlan`创建虚拟局域网连接，给容器增加 [ipvlan ](https://www.kernel.org/doc/Documentation/networking/ipvlan.txt)接口，他主要有两种模式：\n\n- L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX/TX多播和广播（如本机启用的话）。\n- L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播/广播流量，也无法发送多播/广播流量\n\n这个模式创建对象的例子\n\n``` c\n  +=============================================================+\n  |  Host: host1                                                |\n  |                                                             |\n  |                                                             |\n  |   +----------------------+      +----------------------+    |\n  |   |   NS:ns0             |      |  NS:ns1              |    |\n  |   |                      |      |                      |    |\n  |   |                      |      |                      |    |\n  |   |        ipvl0         |      |         ipvl1        |    |\n  |   +----------#-----------+      +-----------#----------+    |\n  |              #                              #               |\n  |              ################################               |\n  |                              # eth0                         |\n  +==============================#==============================+\n（a） 创建两个网络命名空间 - ns0、ns1\n\t\tIP 网络添加 NS0\n\t\tIP 网络添加 NS1\n\n（b） 在 eth0（主设备）上创建两个 ipvlan 从站。\n\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2\n\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2\n\n（c） 将从属服务器分配到相应的网络命名空间\n\t\tIP link set dev ipvl0 netns ns0\n\t\tIP link set dev ipvl1 netns ns1\n\n（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备\n\t\t- 对于 ns0\n\t\t\t（1） IP netns exec ns0 bash\n\t\t\t（2） IP 链路设置开发 IPvl0 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl0\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl0 添加默认值\n\t\t- 对于 ns1\n\t\t\t（1） IP Netns exec NS1 Bash\n\t\t\t（2） IP 链路设置开发 IPvl1 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl1\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl1 添加默认值\n```\n\n\n\n### [`ptp`](https://www.cni.dev/plugins/current/main/ptp/) \n\n​\t该插件只会创建 veth 对\n\n### [`host-device`](https://www.cni.dev/plugins/current/main/host-device/)\n\n​\t将现有的网络设备移动到容器中\n\n### [`vlan`](https://www.cni.dev/plugins/current/main/vlan/) \n\n​\t将会创建一个独立于宿主机的 vxlan 网络接口\n\n### Windows: windows specific \n\n#### [`win-bridge`](https://www.cni.dev/plugins/current/main/win-bridge/) \n\n \t创建虚拟网桥并把本机和（单个）容器连接到这个网桥上\n\n#### [`win-overlay`](https://www.cni.dev/plugins/current/main/win-overlay/) \n\n​\t创建 overlay 接口给 容器\n\n---\n\n## 2. IPAM 插件\n\n### [`dhcp`](https://www.cni.dev/plugins/current/ipam/dhcp/) \n\n​\t给对应容器创建守护进程，这个进程用于发送DHCP请求给网关\n\n### [`host-local`](https://www.cni.dev/plugins/current/ipam/host-local/) \n\n​\t依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件\n\n### [`static`](https://www.cni.dev/plugins/current/ipam/static/) \n\n​\t分配指定条件的IPv4 和IPv6地址给容器\n\n---\n\n\n\n## 3. Meta 多功能插件\n\n### [`tuning`](https://www.cni.dev/plugins/current/meta/tuning/) \n\n​\t改变现有网络接口的 `sysctl` 参数\n\n### [`portmap`](https://www.cni.dev/plugins/current/meta/portmap/)\n\n​\t使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射\n\n### [`bandwidth`](https://www.cni.dev/plugins/current/meta/bandwidth/) \n\n​\t使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽\n\n### [`sbr`](https://www.cni.dev/plugins/current/meta/sbr/)\n\n \t为网络设备提供源路由的配置功能\n\n### [`firewall`](https://www.cni.dev/plugins/current/meta/firewall/) \n\n通过 `iptables` 增添路由规则来控制允许出入容器的流量\n\n以上这些基础插件的代码位置位于：[plugins/plugins at main · containernetworking/plugins (github.com)](https://github.com/containernetworking/plugins/tree/main/plugins)\n\n\n\n## 第三方 CNI 插件\n\n第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。\n\n为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。\n\n\n\n### [Project Calico - a layer 3 virtual network](https://github.com/projectcalico/calico)\n\n> \n\n仓库位置是：[calico/cni-plugin at master · projectcalico/calico (github.com)](https://github.com/projectcalico/calico/tree/master/cni-plugin)\n\n相关文档是：[Configure the Calico CNI plugins | Calico Documentation (tigera.io)](https://docs.tigera.io/calico/latest/reference/configure-cni-plugins)\n\n\n\n### [Weave - a multi-host Docker network](https://github.com/weaveworks/weave)\n\n仓库位置是：[weave/plugin at master · weaveworks/weave (github.com)](https://github.com/weaveworks/weave/tree/master/plugin)\n\n相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)](https://www.weave.works/docs/net/latest/kubernetes/)\n\n\n\n### [Cilium - BPF & XDP for containers](https://github.com/cilium/cilium)\n\n仓库位置是：[cilium/plugins/cilium-cni at main · cilium/cilium (github.com)](https://github.com/cilium/cilium/tree/main/plugins/cilium-cni)\n\n相关文档是：[CNI Chaining — Cilium 1.13.2 documentation](https://docs.cilium.io/en/stable/installation/cni-chaining/#id1)\n\n\n\n### [Contiv Networking - policy networking for various use cases](https://github.com/contiv/netplugin)\n\n仓库位置是：[contiv/netplugin: Container networking for various use cases (github.com)](https://github.com/contiv/netplugin)\n\n相关文档是：无\n\n\n\n### [SR-IOV](https://github.com/hustcat/sriov-cni)\n\n仓库位置是：[hustcat/sriov-cni: SR-IOV CNI plugin (github.com)](https://github.com/hustcat/sriov-cni)\n\n相关文档是：[What is SR-IOV? - Scott's Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)](https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/)\n\n\n\n### [Infoblox - enterprise IP address management for containers](https://github.com/infobloxopen/cni-infoblox)\n\n仓库位置是：[infobloxopen/cni-infoblox: CNI Infoblox Code (github.com)](https://github.com/infobloxopen/cni-infoblox)\n\n相关文档是：[CNI Networking and IPAM (infoblox.com)](https://blogs.infoblox.com/community/cni-networking-and-ipam/)\n\n\n\n### [Multus - a Multi plugin](https://github.com/k8snetworkplumbingwg/multus-cni)\n\n仓库位置是：[k8snetworkplumbingwg/multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)](https://github.com/k8snetworkplumbingwg/multus-cni)\n\n相关文档是：[multus-cni/how-to-use.md at master · k8snetworkplumbingwg/multus-cni (github.com)](https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md)\n\n\n\n### [Romana - Layer 3 CNI plugin supporting network policy for Kubernetes](https://github.com/romana/kube)\n\n仓库位置是：[romana/kube: Kubernetes specific components for Romana (github.com)](https://github.com/romana/kube)\n\n相关文档是：[romana/romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)](https://github.com/romana/romana)\n\n\n\n### [CNI-Genie - generic CNI network plugin](https://github.com/Huawei-PaaS/CNI-Genie)\n\n仓库位置是：[huawei-cloudnative/CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)](https://github.com/huawei-cloudnative/CNI-Genie)\n\n相关文档是：同一仓库\n\n\n\n### [Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support](https://github.com/nuagenetworks/nuage-cni)\n\n仓库位置是：[nuagenetworks/nuage-cni: Nuage VSP plugin for the CNI project (github.com)](https://github.com/nuagenetworks/nuage-cni)\n\n相关文档是：同一仓库\n\n\n\n### [Silk - a CNI plugin designed for Cloud Foundry](https://github.com/cloudfoundry-incubator/silk)\n\n仓库位置是：[cloudfoundry/silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)](https://github.com/cloudfoundry/silk)\n\n相关文档是：同一位置\n\n\n\n### [Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment](https://github.com/John-Lin/linen-cni)\n\n仓库位置是：[John-Lin/linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)](https://github.com/John-Lin/linen-cni)\n\n相关文档是：同一仓库\n\n\n\n### [Vhostuser - a Dataplane network plugin - Supports OVS-DPDK & VPP](https://github.com/intel/vhost-user-net-plugin)\n\n仓库位置是：[intel/userspace-cni-network-plugin (github.com)](https://github.com/intel/userspace-cni-network-plugin)\n\n相关文档是：[Userspace CNI Design document - Google 文档](https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami)\n\n\n\n### [Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)](https://github.com/aws/amazon-ecs-cni-plugins)\n\n仓库位置是：[aws/amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)](https://github.com/aws/amazon-ecs-cni-plugins)\n\n相关文档是：[What is Amazon Elastic Container Service? - Amazon Elastic Container Service](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html)\n\n\n\n### [Bonding CNI - a Link aggregating plugin to address failover and high availability network](https://github.com/Intel-Corp/bond-cni)\n\n仓库位置是：[k8snetworkplumbingwg/bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)](https://github.com/k8snetworkplumbingwg/bond-cni)\n\n相关文档是：同一位置\n\n\n\n### [ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows](https://github.com/openvswitch/ovn-kubernetes)\n\n仓库位置是：[ovn-org/ovn-kubernetes: Kubernetes integration for OVN (github.com)](https://github.com/ovn-org/ovn-kubernetes)\n\n相关文档是：[Installing Open vSwitch — Open vSwitch 3.1.90 documentation](https://docs.openvswitch.org/en/latest/intro/install/)\n\n\n\n### [Juniper Contrail](https://www.juniper.net/cloud) / [TungstenFabric](https://tungstenfabric.io/) - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing\n\n仓库位置是：[Enterprise IT Networking Products & Solutions | Juniper Networks US](https://www.juniper.net/us/en/it-networking.html)\n\n相关文档是：[Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.](https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx)\n\n> 无法参考，为保证资料完整性留存\n\n\n\n### [Knitter - a CNI plugin supporting multiple networking for Kubernetes](https://github.com/ZTE/Knitter)\n\n仓库位置是：[ZTE/Knitter: Kubernetes network solution (github.com)](https://github.com/ZTE/Knitter)\n\n相关文档是：[Knitter/docs at master · ZTE/Knitter (github.com)](https://github.com/ZTE/Knitter/tree/master/docs)\n\n\n\n### [DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes](https://github.com/nokia/danm)\n\n仓库位置是：[nokia/danm: TelCo grade network management in a Kubernetes cluster (github.com)](https://github.com/nokia/danm)\n\n相关文档是：[danm/deployment-guide.md at master · nokia/danm (github.com)](https://github.com/nokia/danm/blob/master/deployment-guide.md)\n\n\n\n### [VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.](https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html)\n\n仓库位置是：[weave/plugin at master · weaveworks/weave (github.com)](https://github.com/weaveworks/weave/tree/master/plugin)\n\n相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]\n\n\n\n### [cni-route-override - a meta CNI plugin that override route information](https://github.com/redhat-nfvpe/cni-route-override)\n\n仓库位置是：[redhat-nfvpe/cni-route-override: CNI plugin to override routes for a container interface (github.com)](https://github.com/redhat-nfvpe/cni-route-override)\n\n相关文档是：同一位置\n\n\n\n\n\n### [Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product](https://github.com/AliyunContainerService/terway)\n\n仓库位置是：[AliyunContainerService/terway: CNI plugin for Alibaba Cloud VPC/ENI (github.com)](https://github.com/AliyunContainerService/terway)\n\n相关文档是：同一位置\n\n\n\n\n\n### [Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.](https://github.com/noironetworks/aci-containers)\n\n仓库位置是：[noironetworks/aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)](https://github.com/noironetworks/aci-containers)\n\n相关文档是：同一位置\n\n\n\n### [Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.](https://github.com/kubeovn/kube-ovn)\n\n仓库位置是：[kubeovn/kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)](https://github.com/kubeovn/kube-ovn)\n\n相关文档是：[kube-ovn/install.md at master · kubeovn/kube-ovn (github.com)](https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md)\n\n\n\n### [Project Antrea - an Open vSwitch k8s CNI](https://github.com/vmware-tanzu/antrea)\n\n仓库位置是：[antrea-io/antrea: Kubernetes networking based on Open vSwitch (github.com)](https://github.com/antrea-io/antrea)\n\n相关文档是：[antrea/getting-started.md at main · antrea-io/antrea (github.com)](https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md)\n\n\n\n### [OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking](https://github.com/opnfv/ovn4nfv-k8s-plugin)\n\n仓库位置是：[opnfv/ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.](https://github.com/opnfv/ovn4nfv-k8s-plugin)\n\n相关文档是：同一位置\n\n> 已经关闭\n\n\n\n### [Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers](https://github.com/Azure/azure-container-networking)\n\n仓库位置是：[Azure/azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)](https://github.com/Azure/azure-container-networking)\n\n相关文档是：[azure-container-networking/docs at master · Azure/azure-container-networking (github.com)](https://github.com/Azure/azure-container-networking/tree/master/docs)\n\n\n\n### [Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.](https://github.com/alibaba/hybridnet)\n\n仓库位置是：[alibaba/hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)](https://github.com/alibaba/hybridnet)\n\n相关文档是：[Home · alibaba/hybridnet Wiki (github.com)](https://github.com/alibaba/hybridnet/wiki)\n\n\n\n### [Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network](https://github.com/spidernet-io/spiderpool)\n\n仓库位置是：[spidernet-io/spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)](https://github.com/spidernet-io/spiderpool)\n\n相关文档是：[spiderpool/install.md at main · spidernet-io/spiderpool (github.com)](https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md)\n\n\n\n\n\n\n\n","source":"_posts/2024/04/cni-research.md","raw":"---\ntitle: CNI Plugins 调研\ndate: 2024-04-11 22:18:42\ntags: ospp, cni, Linux\ncategories: EdgeMesh\ncatalog: true\n---\n# CNI Plugins 调研\n\n## 1. 通用 CNI 插件\n\n> 主要基于 [containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)](https://github.com/containernetworking/plugins) ，[CNI](https://www.cni.dev/plugins/current/)\n\n由CNI 官方社区维护的 CNI plugins 主要分为三类：\n\n* `Main: interface-creating`: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等\n* `IPAM: IP address allocation`:  地址管理插件，主要负责 IP 地址管理和分配\n* `Meta: other plugins`: 其他的功能插件\n\n\n\n### Main: interface-creating  主进程 CNI \n\n### [`bridge`](https://www.cni.dev/plugins/current/main/bridge/) \n\n​\t创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中\n\n### [`macvlan`](https://www.cni.dev/plugins/current/main/macvlan/)\n\n​\t创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址\n\n### [`ipvlan`](https://www.cni.dev/plugins/current/main/ipvlan/) \n\n​\t类似于 `macvlan`创建虚拟局域网连接，给容器增加 [ipvlan ](https://www.kernel.org/doc/Documentation/networking/ipvlan.txt)接口，他主要有两种模式：\n\n- L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX/TX多播和广播（如本机启用的话）。\n- L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播/广播流量，也无法发送多播/广播流量\n\n这个模式创建对象的例子\n\n``` c\n  +=============================================================+\n  |  Host: host1                                                |\n  |                                                             |\n  |                                                             |\n  |   +----------------------+      +----------------------+    |\n  |   |   NS:ns0             |      |  NS:ns1              |    |\n  |   |                      |      |                      |    |\n  |   |                      |      |                      |    |\n  |   |        ipvl0         |      |         ipvl1        |    |\n  |   +----------#-----------+      +-----------#----------+    |\n  |              #                              #               |\n  |              ################################               |\n  |                              # eth0                         |\n  +==============================#==============================+\n（a） 创建两个网络命名空间 - ns0、ns1\n\t\tIP 网络添加 NS0\n\t\tIP 网络添加 NS1\n\n（b） 在 eth0（主设备）上创建两个 ipvlan 从站。\n\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2\n\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2\n\n（c） 将从属服务器分配到相应的网络命名空间\n\t\tIP link set dev ipvl0 netns ns0\n\t\tIP link set dev ipvl1 netns ns1\n\n（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备\n\t\t- 对于 ns0\n\t\t\t（1） IP netns exec ns0 bash\n\t\t\t（2） IP 链路设置开发 IPvl0 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl0\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl0 添加默认值\n\t\t- 对于 ns1\n\t\t\t（1） IP Netns exec NS1 Bash\n\t\t\t（2） IP 链路设置开发 IPvl1 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl1\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl1 添加默认值\n```\n\n\n\n### [`ptp`](https://www.cni.dev/plugins/current/main/ptp/) \n\n​\t该插件只会创建 veth 对\n\n### [`host-device`](https://www.cni.dev/plugins/current/main/host-device/)\n\n​\t将现有的网络设备移动到容器中\n\n### [`vlan`](https://www.cni.dev/plugins/current/main/vlan/) \n\n​\t将会创建一个独立于宿主机的 vxlan 网络接口\n\n### Windows: windows specific \n\n#### [`win-bridge`](https://www.cni.dev/plugins/current/main/win-bridge/) \n\n \t创建虚拟网桥并把本机和（单个）容器连接到这个网桥上\n\n#### [`win-overlay`](https://www.cni.dev/plugins/current/main/win-overlay/) \n\n​\t创建 overlay 接口给 容器\n\n---\n\n## 2. IPAM 插件\n\n### [`dhcp`](https://www.cni.dev/plugins/current/ipam/dhcp/) \n\n​\t给对应容器创建守护进程，这个进程用于发送DHCP请求给网关\n\n### [`host-local`](https://www.cni.dev/plugins/current/ipam/host-local/) \n\n​\t依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件\n\n### [`static`](https://www.cni.dev/plugins/current/ipam/static/) \n\n​\t分配指定条件的IPv4 和IPv6地址给容器\n\n---\n\n\n\n## 3. Meta 多功能插件\n\n### [`tuning`](https://www.cni.dev/plugins/current/meta/tuning/) \n\n​\t改变现有网络接口的 `sysctl` 参数\n\n### [`portmap`](https://www.cni.dev/plugins/current/meta/portmap/)\n\n​\t使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射\n\n### [`bandwidth`](https://www.cni.dev/plugins/current/meta/bandwidth/) \n\n​\t使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽\n\n### [`sbr`](https://www.cni.dev/plugins/current/meta/sbr/)\n\n \t为网络设备提供源路由的配置功能\n\n### [`firewall`](https://www.cni.dev/plugins/current/meta/firewall/) \n\n通过 `iptables` 增添路由规则来控制允许出入容器的流量\n\n以上这些基础插件的代码位置位于：[plugins/plugins at main · containernetworking/plugins (github.com)](https://github.com/containernetworking/plugins/tree/main/plugins)\n\n\n\n## 第三方 CNI 插件\n\n第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。\n\n为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。\n\n\n\n### [Project Calico - a layer 3 virtual network](https://github.com/projectcalico/calico)\n\n> \n\n仓库位置是：[calico/cni-plugin at master · projectcalico/calico (github.com)](https://github.com/projectcalico/calico/tree/master/cni-plugin)\n\n相关文档是：[Configure the Calico CNI plugins | Calico Documentation (tigera.io)](https://docs.tigera.io/calico/latest/reference/configure-cni-plugins)\n\n\n\n### [Weave - a multi-host Docker network](https://github.com/weaveworks/weave)\n\n仓库位置是：[weave/plugin at master · weaveworks/weave (github.com)](https://github.com/weaveworks/weave/tree/master/plugin)\n\n相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)](https://www.weave.works/docs/net/latest/kubernetes/)\n\n\n\n### [Cilium - BPF & XDP for containers](https://github.com/cilium/cilium)\n\n仓库位置是：[cilium/plugins/cilium-cni at main · cilium/cilium (github.com)](https://github.com/cilium/cilium/tree/main/plugins/cilium-cni)\n\n相关文档是：[CNI Chaining — Cilium 1.13.2 documentation](https://docs.cilium.io/en/stable/installation/cni-chaining/#id1)\n\n\n\n### [Contiv Networking - policy networking for various use cases](https://github.com/contiv/netplugin)\n\n仓库位置是：[contiv/netplugin: Container networking for various use cases (github.com)](https://github.com/contiv/netplugin)\n\n相关文档是：无\n\n\n\n### [SR-IOV](https://github.com/hustcat/sriov-cni)\n\n仓库位置是：[hustcat/sriov-cni: SR-IOV CNI plugin (github.com)](https://github.com/hustcat/sriov-cni)\n\n相关文档是：[What is SR-IOV? - Scott's Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)](https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/)\n\n\n\n### [Infoblox - enterprise IP address management for containers](https://github.com/infobloxopen/cni-infoblox)\n\n仓库位置是：[infobloxopen/cni-infoblox: CNI Infoblox Code (github.com)](https://github.com/infobloxopen/cni-infoblox)\n\n相关文档是：[CNI Networking and IPAM (infoblox.com)](https://blogs.infoblox.com/community/cni-networking-and-ipam/)\n\n\n\n### [Multus - a Multi plugin](https://github.com/k8snetworkplumbingwg/multus-cni)\n\n仓库位置是：[k8snetworkplumbingwg/multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)](https://github.com/k8snetworkplumbingwg/multus-cni)\n\n相关文档是：[multus-cni/how-to-use.md at master · k8snetworkplumbingwg/multus-cni (github.com)](https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md)\n\n\n\n### [Romana - Layer 3 CNI plugin supporting network policy for Kubernetes](https://github.com/romana/kube)\n\n仓库位置是：[romana/kube: Kubernetes specific components for Romana (github.com)](https://github.com/romana/kube)\n\n相关文档是：[romana/romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)](https://github.com/romana/romana)\n\n\n\n### [CNI-Genie - generic CNI network plugin](https://github.com/Huawei-PaaS/CNI-Genie)\n\n仓库位置是：[huawei-cloudnative/CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)](https://github.com/huawei-cloudnative/CNI-Genie)\n\n相关文档是：同一仓库\n\n\n\n### [Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support](https://github.com/nuagenetworks/nuage-cni)\n\n仓库位置是：[nuagenetworks/nuage-cni: Nuage VSP plugin for the CNI project (github.com)](https://github.com/nuagenetworks/nuage-cni)\n\n相关文档是：同一仓库\n\n\n\n### [Silk - a CNI plugin designed for Cloud Foundry](https://github.com/cloudfoundry-incubator/silk)\n\n仓库位置是：[cloudfoundry/silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)](https://github.com/cloudfoundry/silk)\n\n相关文档是：同一位置\n\n\n\n### [Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment](https://github.com/John-Lin/linen-cni)\n\n仓库位置是：[John-Lin/linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)](https://github.com/John-Lin/linen-cni)\n\n相关文档是：同一仓库\n\n\n\n### [Vhostuser - a Dataplane network plugin - Supports OVS-DPDK & VPP](https://github.com/intel/vhost-user-net-plugin)\n\n仓库位置是：[intel/userspace-cni-network-plugin (github.com)](https://github.com/intel/userspace-cni-network-plugin)\n\n相关文档是：[Userspace CNI Design document - Google 文档](https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami)\n\n\n\n### [Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)](https://github.com/aws/amazon-ecs-cni-plugins)\n\n仓库位置是：[aws/amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)](https://github.com/aws/amazon-ecs-cni-plugins)\n\n相关文档是：[What is Amazon Elastic Container Service? - Amazon Elastic Container Service](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html)\n\n\n\n### [Bonding CNI - a Link aggregating plugin to address failover and high availability network](https://github.com/Intel-Corp/bond-cni)\n\n仓库位置是：[k8snetworkplumbingwg/bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)](https://github.com/k8snetworkplumbingwg/bond-cni)\n\n相关文档是：同一位置\n\n\n\n### [ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows](https://github.com/openvswitch/ovn-kubernetes)\n\n仓库位置是：[ovn-org/ovn-kubernetes: Kubernetes integration for OVN (github.com)](https://github.com/ovn-org/ovn-kubernetes)\n\n相关文档是：[Installing Open vSwitch — Open vSwitch 3.1.90 documentation](https://docs.openvswitch.org/en/latest/intro/install/)\n\n\n\n### [Juniper Contrail](https://www.juniper.net/cloud) / [TungstenFabric](https://tungstenfabric.io/) - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing\n\n仓库位置是：[Enterprise IT Networking Products & Solutions | Juniper Networks US](https://www.juniper.net/us/en/it-networking.html)\n\n相关文档是：[Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.](https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx)\n\n> 无法参考，为保证资料完整性留存\n\n\n\n### [Knitter - a CNI plugin supporting multiple networking for Kubernetes](https://github.com/ZTE/Knitter)\n\n仓库位置是：[ZTE/Knitter: Kubernetes network solution (github.com)](https://github.com/ZTE/Knitter)\n\n相关文档是：[Knitter/docs at master · ZTE/Knitter (github.com)](https://github.com/ZTE/Knitter/tree/master/docs)\n\n\n\n### [DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes](https://github.com/nokia/danm)\n\n仓库位置是：[nokia/danm: TelCo grade network management in a Kubernetes cluster (github.com)](https://github.com/nokia/danm)\n\n相关文档是：[danm/deployment-guide.md at master · nokia/danm (github.com)](https://github.com/nokia/danm/blob/master/deployment-guide.md)\n\n\n\n### [VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.](https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html)\n\n仓库位置是：[weave/plugin at master · weaveworks/weave (github.com)](https://github.com/weaveworks/weave/tree/master/plugin)\n\n相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]\n\n\n\n### [cni-route-override - a meta CNI plugin that override route information](https://github.com/redhat-nfvpe/cni-route-override)\n\n仓库位置是：[redhat-nfvpe/cni-route-override: CNI plugin to override routes for a container interface (github.com)](https://github.com/redhat-nfvpe/cni-route-override)\n\n相关文档是：同一位置\n\n\n\n\n\n### [Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product](https://github.com/AliyunContainerService/terway)\n\n仓库位置是：[AliyunContainerService/terway: CNI plugin for Alibaba Cloud VPC/ENI (github.com)](https://github.com/AliyunContainerService/terway)\n\n相关文档是：同一位置\n\n\n\n\n\n### [Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.](https://github.com/noironetworks/aci-containers)\n\n仓库位置是：[noironetworks/aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)](https://github.com/noironetworks/aci-containers)\n\n相关文档是：同一位置\n\n\n\n### [Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.](https://github.com/kubeovn/kube-ovn)\n\n仓库位置是：[kubeovn/kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)](https://github.com/kubeovn/kube-ovn)\n\n相关文档是：[kube-ovn/install.md at master · kubeovn/kube-ovn (github.com)](https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md)\n\n\n\n### [Project Antrea - an Open vSwitch k8s CNI](https://github.com/vmware-tanzu/antrea)\n\n仓库位置是：[antrea-io/antrea: Kubernetes networking based on Open vSwitch (github.com)](https://github.com/antrea-io/antrea)\n\n相关文档是：[antrea/getting-started.md at main · antrea-io/antrea (github.com)](https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md)\n\n\n\n### [OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking](https://github.com/opnfv/ovn4nfv-k8s-plugin)\n\n仓库位置是：[opnfv/ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.](https://github.com/opnfv/ovn4nfv-k8s-plugin)\n\n相关文档是：同一位置\n\n> 已经关闭\n\n\n\n### [Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers](https://github.com/Azure/azure-container-networking)\n\n仓库位置是：[Azure/azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)](https://github.com/Azure/azure-container-networking)\n\n相关文档是：[azure-container-networking/docs at master · Azure/azure-container-networking (github.com)](https://github.com/Azure/azure-container-networking/tree/master/docs)\n\n\n\n### [Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.](https://github.com/alibaba/hybridnet)\n\n仓库位置是：[alibaba/hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)](https://github.com/alibaba/hybridnet)\n\n相关文档是：[Home · alibaba/hybridnet Wiki (github.com)](https://github.com/alibaba/hybridnet/wiki)\n\n\n\n### [Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network](https://github.com/spidernet-io/spiderpool)\n\n仓库位置是：[spidernet-io/spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)](https://github.com/spidernet-io/spiderpool)\n\n相关文档是：[spiderpool/install.md at main · spidernet-io/spiderpool (github.com)](https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md)\n\n\n\n\n\n\n\n","slug":"cni-research","published":1,"updated":"2024-04-11T14:20:38.707Z","_id":"cluvbsnov000382pe9v07ecmy","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"CNI-Plugins-调研\"><a href=\"#CNI-Plugins-调研\" class=\"headerlink\" title=\"CNI Plugins 调研\"></a>CNI Plugins 调研</h1><h2 id=\"1-通用-CNI-插件\"><a href=\"#1-通用-CNI-插件\" class=\"headerlink\" title=\"1. 通用 CNI 插件\"></a>1. 通用 CNI 插件</h2><blockquote>\n<p>主要基于 <a href=\"https://github.com/containernetworking/plugins\">containernetworking&#x2F;plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a> ，<a href=\"https://www.cni.dev/plugins/current/\">CNI</a></p>\n</blockquote>\n<p>由CNI 官方社区维护的 CNI plugins 主要分为三类：</p>\n<ul>\n<li><code>Main: interface-creating</code>: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等</li>\n<li><code>IPAM: IP address allocation</code>:  地址管理插件，主要负责 IP 地址管理和分配</li>\n<li><code>Meta: other plugins</code>: 其他的功能插件</li>\n</ul>\n<h3 id=\"Main-interface-creating-主进程-CNI\"><a href=\"#Main-interface-creating-主进程-CNI\" class=\"headerlink\" title=\"Main: interface-creating  主进程 CNI\"></a>Main: interface-creating  主进程 CNI</h3><h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/bridge/\"><code>bridge</code></a></h3><p>​\t创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中</p>\n<h3 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/macvlan/\"><code>macvlan</code></a></h3><p>​\t创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址</p>\n<h3 id=\"ipvlan\"><a href=\"#ipvlan\" class=\"headerlink\" title=\"ipvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/ipvlan/\"><code>ipvlan</code></a></h3><p>​\t类似于 <code>macvlan</code>创建虚拟局域网连接，给容器增加 <a href=\"https://www.kernel.org/doc/Documentation/networking/ipvlan.txt\">ipvlan </a>接口，他主要有两种模式：</p>\n<ul>\n<li>L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX&#x2F;TX多播和广播（如本机启用的话）。</li>\n<li>L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播&#x2F;广播流量，也无法发送多播&#x2F;广播流量</li>\n</ul>\n<p>这个模式创建对象的例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  +=============================================================+</span><br><span class=\"line\">  |  Host: host1                                                |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |   +----------------------+      +----------------------+    |</span><br><span class=\"line\">  |   |   NS:ns0             |      |  NS:ns1              |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |        ipvl0         |      |         ipvl1        |    |</span><br><span class=\"line\">  |   +----------#-----------+      +-----------#----------+    |</span><br><span class=\"line\">  |              #                              #               |</span><br><span class=\"line\">  |              ################################               |</span><br><span class=\"line\">  |                              # eth0                         |</span><br><span class=\"line\">  +==============================#==============================+</span><br><span class=\"line\">（a） 创建两个网络命名空间 - ns0、ns1</span><br><span class=\"line\">\t\tIP 网络添加 NS0</span><br><span class=\"line\">\t\tIP 网络添加 NS1</span><br><span class=\"line\"></span><br><span class=\"line\">（b） 在 eth0（主设备）上创建两个 ipvlan 从站。</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2</span><br><span class=\"line\"></span><br><span class=\"line\">（c） 将从属服务器分配到相应的网络命名空间</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl0 netns ns0</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl1 netns ns1</span><br><span class=\"line\"></span><br><span class=\"line\">（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备</span><br><span class=\"line\">\t\t- 对于 ns0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP netns exec ns0 bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl0 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl0 添加默认值</span><br><span class=\"line\">\t\t- 对于 ns1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP Netns exec NS1 Bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl1 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl1 添加默认值</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"ptp\"><a href=\"#ptp\" class=\"headerlink\" title=\"ptp\"></a><a href=\"https://www.cni.dev/plugins/current/main/ptp/\"><code>ptp</code></a></h3><p>​\t该插件只会创建 veth 对</p>\n<h3 id=\"host-device\"><a href=\"#host-device\" class=\"headerlink\" title=\"host-device\"></a><a href=\"https://www.cni.dev/plugins/current/main/host-device/\"><code>host-device</code></a></h3><p>​\t将现有的网络设备移动到容器中</p>\n<h3 id=\"vlan\"><a href=\"#vlan\" class=\"headerlink\" title=\"vlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/vlan/\"><code>vlan</code></a></h3><p>​\t将会创建一个独立于宿主机的 vxlan 网络接口</p>\n<h3 id=\"Windows-windows-specific\"><a href=\"#Windows-windows-specific\" class=\"headerlink\" title=\"Windows: windows specific\"></a>Windows: windows specific</h3><h4 id=\"win-bridge\"><a href=\"#win-bridge\" class=\"headerlink\" title=\"win-bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/win-bridge/\"><code>win-bridge</code></a></h4><pre><code> 创建虚拟网桥并把本机和（单个）容器连接到这个网桥上\n</code></pre>\n<h4 id=\"win-overlay\"><a href=\"#win-overlay\" class=\"headerlink\" title=\"win-overlay\"></a><a href=\"https://www.cni.dev/plugins/current/main/win-overlay/\"><code>win-overlay</code></a></h4><p>​\t创建 overlay 接口给 容器</p>\n<hr>\n<h2 id=\"2-IPAM-插件\"><a href=\"#2-IPAM-插件\" class=\"headerlink\" title=\"2. IPAM 插件\"></a>2. IPAM 插件</h2><h3 id=\"dhcp\"><a href=\"#dhcp\" class=\"headerlink\" title=\"dhcp\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/dhcp/\"><code>dhcp</code></a></h3><p>​\t给对应容器创建守护进程，这个进程用于发送DHCP请求给网关</p>\n<h3 id=\"host-local\"><a href=\"#host-local\" class=\"headerlink\" title=\"host-local\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/host-local/\"><code>host-local</code></a></h3><p>​\t依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件</p>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/static/\"><code>static</code></a></h3><p>​\t分配指定条件的IPv4 和IPv6地址给容器</p>\n<hr>\n<h2 id=\"3-Meta-多功能插件\"><a href=\"#3-Meta-多功能插件\" class=\"headerlink\" title=\"3. Meta 多功能插件\"></a>3. Meta 多功能插件</h2><h3 id=\"tuning\"><a href=\"#tuning\" class=\"headerlink\" title=\"tuning\"></a><a href=\"https://www.cni.dev/plugins/current/meta/tuning/\"><code>tuning</code></a></h3><p>​\t改变现有网络接口的 <code>sysctl</code> 参数</p>\n<h3 id=\"portmap\"><a href=\"#portmap\" class=\"headerlink\" title=\"portmap\"></a><a href=\"https://www.cni.dev/plugins/current/meta/portmap/\"><code>portmap</code></a></h3><p>​\t使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射</p>\n<h3 id=\"bandwidth\"><a href=\"#bandwidth\" class=\"headerlink\" title=\"bandwidth\"></a><a href=\"https://www.cni.dev/plugins/current/meta/bandwidth/\"><code>bandwidth</code></a></h3><p>​\t使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽</p>\n<h3 id=\"sbr\"><a href=\"#sbr\" class=\"headerlink\" title=\"sbr\"></a><a href=\"https://www.cni.dev/plugins/current/meta/sbr/\"><code>sbr</code></a></h3><pre><code> 为网络设备提供源路由的配置功能\n</code></pre>\n<h3 id=\"firewall\"><a href=\"#firewall\" class=\"headerlink\" title=\"firewall\"></a><a href=\"https://www.cni.dev/plugins/current/meta/firewall/\"><code>firewall</code></a></h3><p>通过 <code>iptables</code> 增添路由规则来控制允许出入容器的流量</p>\n<p>以上这些基础插件的代码位置位于：<a href=\"https://github.com/containernetworking/plugins/tree/main/plugins\">plugins&#x2F;plugins at main · containernetworking&#x2F;plugins (github.com)</a></p>\n<h2 id=\"第三方-CNI-插件\"><a href=\"#第三方-CNI-插件\" class=\"headerlink\" title=\"第三方 CNI 插件\"></a>第三方 CNI 插件</h2><p>第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。</p>\n<p>为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。</p>\n<h3 id=\"Project-Calico-a-layer-3-virtual-network\"><a href=\"#Project-Calico-a-layer-3-virtual-network\" class=\"headerlink\" title=\"Project Calico - a layer 3 virtual network\"></a><a href=\"https://github.com/projectcalico/calico\">Project Calico - a layer 3 virtual network</a></h3><blockquote>\n</blockquote>\n<p>仓库位置是：<a href=\"https://github.com/projectcalico/calico/tree/master/cni-plugin\">calico&#x2F;cni-plugin at master · projectcalico&#x2F;calico (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.tigera.io/calico/latest/reference/configure-cni-plugins\">Configure the Calico CNI plugins | Calico Documentation (tigera.io)</a></p>\n<h3 id=\"Weave-a-multi-host-Docker-network\"><a href=\"#Weave-a-multi-host-Docker-network\" class=\"headerlink\" title=\"Weave - a multi-host Docker network\"></a><a href=\"https://github.com/weaveworks/weave\">Weave - a multi-host Docker network</a></h3><p>仓库位置是：<a href=\"https://github.com/weaveworks/weave/tree/master/plugin\">weave&#x2F;plugin at master · weaveworks&#x2F;weave (github.com)</a></p>\n<p>相关文档是：<a href=\"https://www.weave.works/docs/net/latest/kubernetes/\">Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)</a></p>\n<h3 id=\"Cilium-BPF-XDP-for-containers\"><a href=\"#Cilium-BPF-XDP-for-containers\" class=\"headerlink\" title=\"Cilium - BPF &amp; XDP for containers\"></a><a href=\"https://github.com/cilium/cilium\">Cilium - BPF &amp; XDP for containers</a></h3><p>仓库位置是：<a href=\"https://github.com/cilium/cilium/tree/main/plugins/cilium-cni\">cilium&#x2F;plugins&#x2F;cilium-cni at main · cilium&#x2F;cilium (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.cilium.io/en/stable/installation/cni-chaining/#id1\">CNI Chaining — Cilium 1.13.2 documentation</a></p>\n<h3 id=\"Contiv-Networking-policy-networking-for-various-use-cases\"><a href=\"#Contiv-Networking-policy-networking-for-various-use-cases\" class=\"headerlink\" title=\"Contiv Networking - policy networking for various use cases\"></a><a href=\"https://github.com/contiv/netplugin\">Contiv Networking - policy networking for various use cases</a></h3><p>仓库位置是：<a href=\"https://github.com/contiv/netplugin\">contiv&#x2F;netplugin: Container networking for various use cases (github.com)</a></p>\n<p>相关文档是：无</p>\n<h3 id=\"SR-IOV\"><a href=\"#SR-IOV\" class=\"headerlink\" title=\"SR-IOV\"></a><a href=\"https://github.com/hustcat/sriov-cni\">SR-IOV</a></h3><p>仓库位置是：<a href=\"https://github.com/hustcat/sriov-cni\">hustcat&#x2F;sriov-cni: SR-IOV CNI plugin (github.com)</a></p>\n<p>相关文档是：<a href=\"https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/\">What is SR-IOV? - Scott’s Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)</a></p>\n<h3 id=\"Infoblox-enterprise-IP-address-management-for-containers\"><a href=\"#Infoblox-enterprise-IP-address-management-for-containers\" class=\"headerlink\" title=\"Infoblox - enterprise IP address management for containers\"></a><a href=\"https://github.com/infobloxopen/cni-infoblox\">Infoblox - enterprise IP address management for containers</a></h3><p>仓库位置是：<a href=\"https://github.com/infobloxopen/cni-infoblox\">infobloxopen&#x2F;cni-infoblox: CNI Infoblox Code (github.com)</a></p>\n<p>相关文档是：<a href=\"https://blogs.infoblox.com/community/cni-networking-and-ipam/\">CNI Networking and IPAM (infoblox.com)</a></p>\n<h3 id=\"Multus-a-Multi-plugin\"><a href=\"#Multus-a-Multi-plugin\" class=\"headerlink\" title=\"Multus - a Multi plugin\"></a><a href=\"https://github.com/k8snetworkplumbingwg/multus-cni\">Multus - a Multi plugin</a></h3><p>仓库位置是：<a href=\"https://github.com/k8snetworkplumbingwg/multus-cni\">k8snetworkplumbingwg&#x2F;multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md\">multus-cni&#x2F;how-to-use.md at master · k8snetworkplumbingwg&#x2F;multus-cni (github.com)</a></p>\n<h3 id=\"Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes\"><a href=\"#Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes\" class=\"headerlink\" title=\"Romana - Layer 3 CNI plugin supporting network policy for Kubernetes\"></a><a href=\"https://github.com/romana/kube\">Romana - Layer 3 CNI plugin supporting network policy for Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/romana/kube\">romana&#x2F;kube: Kubernetes specific components for Romana (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/romana/romana\">romana&#x2F;romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)</a></p>\n<h3 id=\"CNI-Genie-generic-CNI-network-plugin\"><a href=\"#CNI-Genie-generic-CNI-network-plugin\" class=\"headerlink\" title=\"CNI-Genie - generic CNI network plugin\"></a><a href=\"https://github.com/Huawei-PaaS/CNI-Genie\">CNI-Genie - generic CNI network plugin</a></h3><p>仓库位置是：<a href=\"https://github.com/huawei-cloudnative/CNI-Genie\">huawei-cloudnative&#x2F;CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support\"><a href=\"#Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support\" class=\"headerlink\" title=\"Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support\"></a><a href=\"https://github.com/nuagenetworks/nuage-cni\">Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support</a></h3><p>仓库位置是：<a href=\"https://github.com/nuagenetworks/nuage-cni\">nuagenetworks&#x2F;nuage-cni: Nuage VSP plugin for the CNI project (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Silk-a-CNI-plugin-designed-for-Cloud-Foundry\"><a href=\"#Silk-a-CNI-plugin-designed-for-Cloud-Foundry\" class=\"headerlink\" title=\"Silk - a CNI plugin designed for Cloud Foundry\"></a><a href=\"https://github.com/cloudfoundry-incubator/silk\">Silk - a CNI plugin designed for Cloud Foundry</a></h3><p>仓库位置是：<a href=\"https://github.com/cloudfoundry/silk\">cloudfoundry&#x2F;silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment\"><a href=\"#Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment\" class=\"headerlink\" title=\"Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN&#x2F;OpenFlow network environment\"></a><a href=\"https://github.com/John-Lin/linen-cni\">Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN&#x2F;OpenFlow network environment</a></h3><p>仓库位置是：<a href=\"https://github.com/John-Lin/linen-cni\">John-Lin&#x2F;linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-VPP\"><a href=\"#Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-VPP\" class=\"headerlink\" title=\"Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP\"></a><a href=\"https://github.com/intel/vhost-user-net-plugin\">Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP</a></h3><p>仓库位置是：<a href=\"https://github.com/intel/userspace-cni-network-plugin\">intel&#x2F;userspace-cni-network-plugin (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami\">Userspace CNI Design document - Google 文档</a></p>\n<h3 id=\"Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs\"><a href=\"#Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs\" class=\"headerlink\" title=\"Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)\"></a><a href=\"https://github.com/aws/amazon-ecs-cni-plugins\">Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)</a></h3><p>仓库位置是：<a href=\"https://github.com/aws/amazon-ecs-cni-plugins\">aws&#x2F;amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html\">What is Amazon Elastic Container Service? - Amazon Elastic Container Service</a></p>\n<h3 id=\"Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network\"><a href=\"#Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network\" class=\"headerlink\" title=\"Bonding CNI - a Link aggregating plugin to address failover and high availability network\"></a><a href=\"https://github.com/Intel-Corp/bond-cni\">Bonding CNI - a Link aggregating plugin to address failover and high availability network</a></h3><p>仓库位置是：<a href=\"https://github.com/k8snetworkplumbingwg/bond-cni\">k8snetworkplumbingwg&#x2F;bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows\"><a href=\"#ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows\" class=\"headerlink\" title=\"ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows\"></a><a href=\"https://github.com/openvswitch/ovn-kubernetes\">ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows</a></h3><p>仓库位置是：<a href=\"https://github.com/ovn-org/ovn-kubernetes\">ovn-org&#x2F;ovn-kubernetes: Kubernetes integration for OVN (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.openvswitch.org/en/latest/intro/install/\">Installing Open vSwitch — Open vSwitch 3.1.90 documentation</a></p>\n<h3 id=\"Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing\"><a href=\"#Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing\" class=\"headerlink\" title=\"Juniper Contrail &#x2F; TungstenFabric - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing\"></a><a href=\"https://www.juniper.net/cloud\">Juniper Contrail</a> &#x2F; <a href=\"https://tungstenfabric.io/\">TungstenFabric</a> - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing</h3><p>仓库位置是：<a href=\"https://www.juniper.net/us/en/it-networking.html\">Enterprise IT Networking Products &amp; Solutions | Juniper Networks US</a></p>\n<p>相关文档是：<a href=\"https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx\">Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.</a></p>\n<blockquote>\n<p>无法参考，为保证资料完整性留存</p>\n</blockquote>\n<h3 id=\"Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes\"><a href=\"#Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes\" class=\"headerlink\" title=\"Knitter - a CNI plugin supporting multiple networking for Kubernetes\"></a><a href=\"https://github.com/ZTE/Knitter\">Knitter - a CNI plugin supporting multiple networking for Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/ZTE/Knitter\">ZTE&#x2F;Knitter: Kubernetes network solution (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/ZTE/Knitter/tree/master/docs\">Knitter&#x2F;docs at master · ZTE&#x2F;Knitter (github.com)</a></p>\n<h3 id=\"DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes\"><a href=\"#DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes\" class=\"headerlink\" title=\"DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes\"></a><a href=\"https://github.com/nokia/danm\">DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/nokia/danm\">nokia&#x2F;danm: TelCo grade network management in a Kubernetes cluster (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/nokia/danm/blob/master/deployment-guide.md\">danm&#x2F;deployment-guide.md at master · nokia&#x2F;danm (github.com)</a></p>\n<h3 id=\"VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster\"><a href=\"#VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster\" class=\"headerlink\" title=\"VMware NSX – a CNI plugin that enables automated NSX L2&#x2F;L3 networking and L4&#x2F;L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.\"></a><a href=\"https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html\">VMware NSX – a CNI plugin that enables automated NSX L2&#x2F;L3 networking and L4&#x2F;L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.</a></h3><p>仓库位置是：<a href=\"https://github.com/weaveworks/weave/tree/master/plugin\">weave&#x2F;plugin at master · weaveworks&#x2F;weave (github.com)</a></p>\n<p>相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]</p>\n<h3 id=\"cni-route-override-a-meta-CNI-plugin-that-override-route-information\"><a href=\"#cni-route-override-a-meta-CNI-plugin-that-override-route-information\" class=\"headerlink\" title=\"cni-route-override - a meta CNI plugin that override route information\"></a><a href=\"https://github.com/redhat-nfvpe/cni-route-override\">cni-route-override - a meta CNI plugin that override route information</a></h3><p>仓库位置是：<a href=\"https://github.com/redhat-nfvpe/cni-route-override\">redhat-nfvpe&#x2F;cni-route-override: CNI plugin to override routes for a container interface (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product\"><a href=\"#Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product\" class=\"headerlink\" title=\"Terway - a collection of CNI Plugins based on alibaba cloud VPC&#x2F;ECS network product\"></a><a href=\"https://github.com/AliyunContainerService/terway\">Terway - a collection of CNI Plugins based on alibaba cloud VPC&#x2F;ECS network product</a></h3><p>仓库位置是：<a href=\"https://github.com/AliyunContainerService/terway\">AliyunContainerService&#x2F;terway: CNI plugin for Alibaba Cloud VPC&#x2F;ENI (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model\"><a href=\"#Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model\" class=\"headerlink\" title=\"Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.\"></a><a href=\"https://github.com/noironetworks/aci-containers\">Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.</a></h3><p>仓库位置是：<a href=\"https://github.com/noironetworks/aci-containers\">noironetworks&#x2F;aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc\"><a href=\"#Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc\" class=\"headerlink\" title=\"Kube-OVN - a CNI plugin that bases on OVN&#x2F;OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.\"></a><a href=\"https://github.com/kubeovn/kube-ovn\">Kube-OVN - a CNI plugin that bases on OVN&#x2F;OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.</a></h3><p>仓库位置是：<a href=\"https://github.com/kubeovn/kube-ovn\">kubeovn&#x2F;kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md\">kube-ovn&#x2F;install.md at master · kubeovn&#x2F;kube-ovn (github.com)</a></p>\n<h3 id=\"Project-Antrea-an-Open-vSwitch-k8s-CNI\"><a href=\"#Project-Antrea-an-Open-vSwitch-k8s-CNI\" class=\"headerlink\" title=\"Project Antrea - an Open vSwitch k8s CNI\"></a><a href=\"https://github.com/vmware-tanzu/antrea\">Project Antrea - an Open vSwitch k8s CNI</a></h3><p>仓库位置是：<a href=\"https://github.com/antrea-io/antrea\">antrea-io&#x2F;antrea: Kubernetes networking based on Open vSwitch (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md\">antrea&#x2F;getting-started.md at main · antrea-io&#x2F;antrea (github.com)</a></p>\n<h3 id=\"OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking\"><a href=\"#OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking\" class=\"headerlink\" title=\"OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking\"></a><a href=\"https://github.com/opnfv/ovn4nfv-k8s-plugin\">OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking</a></h3><p>仓库位置是：<a href=\"https://github.com/opnfv/ovn4nfv-k8s-plugin\">opnfv&#x2F;ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.</a></p>\n<p>相关文档是：同一位置</p>\n<blockquote>\n<p>已经关闭</p>\n</blockquote>\n<h3 id=\"Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers\"><a href=\"#Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers\" class=\"headerlink\" title=\"Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers\"></a><a href=\"https://github.com/Azure/azure-container-networking\">Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers</a></h3><p>仓库位置是：<a href=\"https://github.com/Azure/azure-container-networking\">Azure&#x2F;azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/Azure/azure-container-networking/tree/master/docs\">azure-container-networking&#x2F;docs at master · Azure&#x2F;azure-container-networking (github.com)</a></p>\n<h3 id=\"Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity\"><a href=\"#Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity\" class=\"headerlink\" title=\"Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.\"></a><a href=\"https://github.com/alibaba/hybridnet\">Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.</a></h3><p>仓库位置是：<a href=\"https://github.com/alibaba/hybridnet\">alibaba&#x2F;hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/alibaba/hybridnet/wiki\">Home · alibaba&#x2F;hybridnet Wiki (github.com)</a></p>\n<h3 id=\"Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network\"><a href=\"#Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network\" class=\"headerlink\" title=\"Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network\"></a><a href=\"https://github.com/spidernet-io/spiderpool\">Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network</a></h3><p>仓库位置是：<a href=\"https://github.com/spidernet-io/spiderpool\">spidernet-io&#x2F;spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md\">spiderpool&#x2F;install.md at main · spidernet-io&#x2F;spiderpool (github.com)</a></p>\n","cover":false,"excerpt":"","more":"<h1 id=\"CNI-Plugins-调研\"><a href=\"#CNI-Plugins-调研\" class=\"headerlink\" title=\"CNI Plugins 调研\"></a>CNI Plugins 调研</h1><h2 id=\"1-通用-CNI-插件\"><a href=\"#1-通用-CNI-插件\" class=\"headerlink\" title=\"1. 通用 CNI 插件\"></a>1. 通用 CNI 插件</h2><blockquote>\n<p>主要基于 <a href=\"https://github.com/containernetworking/plugins\">containernetworking&#x2F;plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a> ，<a href=\"https://www.cni.dev/plugins/current/\">CNI</a></p>\n</blockquote>\n<p>由CNI 官方社区维护的 CNI plugins 主要分为三类：</p>\n<ul>\n<li><code>Main: interface-creating</code>: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等</li>\n<li><code>IPAM: IP address allocation</code>:  地址管理插件，主要负责 IP 地址管理和分配</li>\n<li><code>Meta: other plugins</code>: 其他的功能插件</li>\n</ul>\n<h3 id=\"Main-interface-creating-主进程-CNI\"><a href=\"#Main-interface-creating-主进程-CNI\" class=\"headerlink\" title=\"Main: interface-creating  主进程 CNI\"></a>Main: interface-creating  主进程 CNI</h3><h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/bridge/\"><code>bridge</code></a></h3><p>​\t创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中</p>\n<h3 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/macvlan/\"><code>macvlan</code></a></h3><p>​\t创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址</p>\n<h3 id=\"ipvlan\"><a href=\"#ipvlan\" class=\"headerlink\" title=\"ipvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/ipvlan/\"><code>ipvlan</code></a></h3><p>​\t类似于 <code>macvlan</code>创建虚拟局域网连接，给容器增加 <a href=\"https://www.kernel.org/doc/Documentation/networking/ipvlan.txt\">ipvlan </a>接口，他主要有两种模式：</p>\n<ul>\n<li>L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX&#x2F;TX多播和广播（如本机启用的话）。</li>\n<li>L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播&#x2F;广播流量，也无法发送多播&#x2F;广播流量</li>\n</ul>\n<p>这个模式创建对象的例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  +=============================================================+</span><br><span class=\"line\">  |  Host: host1                                                |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |   +----------------------+      +----------------------+    |</span><br><span class=\"line\">  |   |   NS:ns0             |      |  NS:ns1              |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |        ipvl0         |      |         ipvl1        |    |</span><br><span class=\"line\">  |   +----------#-----------+      +-----------#----------+    |</span><br><span class=\"line\">  |              #                              #               |</span><br><span class=\"line\">  |              ################################               |</span><br><span class=\"line\">  |                              # eth0                         |</span><br><span class=\"line\">  +==============================#==============================+</span><br><span class=\"line\">（a） 创建两个网络命名空间 - ns0、ns1</span><br><span class=\"line\">\t\tIP 网络添加 NS0</span><br><span class=\"line\">\t\tIP 网络添加 NS1</span><br><span class=\"line\"></span><br><span class=\"line\">（b） 在 eth0（主设备）上创建两个 ipvlan 从站。</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2</span><br><span class=\"line\"></span><br><span class=\"line\">（c） 将从属服务器分配到相应的网络命名空间</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl0 netns ns0</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl1 netns ns1</span><br><span class=\"line\"></span><br><span class=\"line\">（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备</span><br><span class=\"line\">\t\t- 对于 ns0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP netns exec ns0 bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl0 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl0 添加默认值</span><br><span class=\"line\">\t\t- 对于 ns1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP Netns exec NS1 Bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl1 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl1 添加默认值</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"ptp\"><a href=\"#ptp\" class=\"headerlink\" title=\"ptp\"></a><a href=\"https://www.cni.dev/plugins/current/main/ptp/\"><code>ptp</code></a></h3><p>​\t该插件只会创建 veth 对</p>\n<h3 id=\"host-device\"><a href=\"#host-device\" class=\"headerlink\" title=\"host-device\"></a><a href=\"https://www.cni.dev/plugins/current/main/host-device/\"><code>host-device</code></a></h3><p>​\t将现有的网络设备移动到容器中</p>\n<h3 id=\"vlan\"><a href=\"#vlan\" class=\"headerlink\" title=\"vlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/vlan/\"><code>vlan</code></a></h3><p>​\t将会创建一个独立于宿主机的 vxlan 网络接口</p>\n<h3 id=\"Windows-windows-specific\"><a href=\"#Windows-windows-specific\" class=\"headerlink\" title=\"Windows: windows specific\"></a>Windows: windows specific</h3><h4 id=\"win-bridge\"><a href=\"#win-bridge\" class=\"headerlink\" title=\"win-bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/win-bridge/\"><code>win-bridge</code></a></h4><pre><code> 创建虚拟网桥并把本机和（单个）容器连接到这个网桥上\n</code></pre>\n<h4 id=\"win-overlay\"><a href=\"#win-overlay\" class=\"headerlink\" title=\"win-overlay\"></a><a href=\"https://www.cni.dev/plugins/current/main/win-overlay/\"><code>win-overlay</code></a></h4><p>​\t创建 overlay 接口给 容器</p>\n<hr>\n<h2 id=\"2-IPAM-插件\"><a href=\"#2-IPAM-插件\" class=\"headerlink\" title=\"2. IPAM 插件\"></a>2. IPAM 插件</h2><h3 id=\"dhcp\"><a href=\"#dhcp\" class=\"headerlink\" title=\"dhcp\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/dhcp/\"><code>dhcp</code></a></h3><p>​\t给对应容器创建守护进程，这个进程用于发送DHCP请求给网关</p>\n<h3 id=\"host-local\"><a href=\"#host-local\" class=\"headerlink\" title=\"host-local\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/host-local/\"><code>host-local</code></a></h3><p>​\t依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件</p>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/static/\"><code>static</code></a></h3><p>​\t分配指定条件的IPv4 和IPv6地址给容器</p>\n<hr>\n<h2 id=\"3-Meta-多功能插件\"><a href=\"#3-Meta-多功能插件\" class=\"headerlink\" title=\"3. Meta 多功能插件\"></a>3. Meta 多功能插件</h2><h3 id=\"tuning\"><a href=\"#tuning\" class=\"headerlink\" title=\"tuning\"></a><a href=\"https://www.cni.dev/plugins/current/meta/tuning/\"><code>tuning</code></a></h3><p>​\t改变现有网络接口的 <code>sysctl</code> 参数</p>\n<h3 id=\"portmap\"><a href=\"#portmap\" class=\"headerlink\" title=\"portmap\"></a><a href=\"https://www.cni.dev/plugins/current/meta/portmap/\"><code>portmap</code></a></h3><p>​\t使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射</p>\n<h3 id=\"bandwidth\"><a href=\"#bandwidth\" class=\"headerlink\" title=\"bandwidth\"></a><a href=\"https://www.cni.dev/plugins/current/meta/bandwidth/\"><code>bandwidth</code></a></h3><p>​\t使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽</p>\n<h3 id=\"sbr\"><a href=\"#sbr\" class=\"headerlink\" title=\"sbr\"></a><a href=\"https://www.cni.dev/plugins/current/meta/sbr/\"><code>sbr</code></a></h3><pre><code> 为网络设备提供源路由的配置功能\n</code></pre>\n<h3 id=\"firewall\"><a href=\"#firewall\" class=\"headerlink\" title=\"firewall\"></a><a href=\"https://www.cni.dev/plugins/current/meta/firewall/\"><code>firewall</code></a></h3><p>通过 <code>iptables</code> 增添路由规则来控制允许出入容器的流量</p>\n<p>以上这些基础插件的代码位置位于：<a href=\"https://github.com/containernetworking/plugins/tree/main/plugins\">plugins&#x2F;plugins at main · containernetworking&#x2F;plugins (github.com)</a></p>\n<h2 id=\"第三方-CNI-插件\"><a href=\"#第三方-CNI-插件\" class=\"headerlink\" title=\"第三方 CNI 插件\"></a>第三方 CNI 插件</h2><p>第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。</p>\n<p>为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。</p>\n<h3 id=\"Project-Calico-a-layer-3-virtual-network\"><a href=\"#Project-Calico-a-layer-3-virtual-network\" class=\"headerlink\" title=\"Project Calico - a layer 3 virtual network\"></a><a href=\"https://github.com/projectcalico/calico\">Project Calico - a layer 3 virtual network</a></h3><blockquote>\n</blockquote>\n<p>仓库位置是：<a href=\"https://github.com/projectcalico/calico/tree/master/cni-plugin\">calico&#x2F;cni-plugin at master · projectcalico&#x2F;calico (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.tigera.io/calico/latest/reference/configure-cni-plugins\">Configure the Calico CNI plugins | Calico Documentation (tigera.io)</a></p>\n<h3 id=\"Weave-a-multi-host-Docker-network\"><a href=\"#Weave-a-multi-host-Docker-network\" class=\"headerlink\" title=\"Weave - a multi-host Docker network\"></a><a href=\"https://github.com/weaveworks/weave\">Weave - a multi-host Docker network</a></h3><p>仓库位置是：<a href=\"https://github.com/weaveworks/weave/tree/master/plugin\">weave&#x2F;plugin at master · weaveworks&#x2F;weave (github.com)</a></p>\n<p>相关文档是：<a href=\"https://www.weave.works/docs/net/latest/kubernetes/\">Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)</a></p>\n<h3 id=\"Cilium-BPF-XDP-for-containers\"><a href=\"#Cilium-BPF-XDP-for-containers\" class=\"headerlink\" title=\"Cilium - BPF &amp; XDP for containers\"></a><a href=\"https://github.com/cilium/cilium\">Cilium - BPF &amp; XDP for containers</a></h3><p>仓库位置是：<a href=\"https://github.com/cilium/cilium/tree/main/plugins/cilium-cni\">cilium&#x2F;plugins&#x2F;cilium-cni at main · cilium&#x2F;cilium (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.cilium.io/en/stable/installation/cni-chaining/#id1\">CNI Chaining — Cilium 1.13.2 documentation</a></p>\n<h3 id=\"Contiv-Networking-policy-networking-for-various-use-cases\"><a href=\"#Contiv-Networking-policy-networking-for-various-use-cases\" class=\"headerlink\" title=\"Contiv Networking - policy networking for various use cases\"></a><a href=\"https://github.com/contiv/netplugin\">Contiv Networking - policy networking for various use cases</a></h3><p>仓库位置是：<a href=\"https://github.com/contiv/netplugin\">contiv&#x2F;netplugin: Container networking for various use cases (github.com)</a></p>\n<p>相关文档是：无</p>\n<h3 id=\"SR-IOV\"><a href=\"#SR-IOV\" class=\"headerlink\" title=\"SR-IOV\"></a><a href=\"https://github.com/hustcat/sriov-cni\">SR-IOV</a></h3><p>仓库位置是：<a href=\"https://github.com/hustcat/sriov-cni\">hustcat&#x2F;sriov-cni: SR-IOV CNI plugin (github.com)</a></p>\n<p>相关文档是：<a href=\"https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/\">What is SR-IOV? - Scott’s Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)</a></p>\n<h3 id=\"Infoblox-enterprise-IP-address-management-for-containers\"><a href=\"#Infoblox-enterprise-IP-address-management-for-containers\" class=\"headerlink\" title=\"Infoblox - enterprise IP address management for containers\"></a><a href=\"https://github.com/infobloxopen/cni-infoblox\">Infoblox - enterprise IP address management for containers</a></h3><p>仓库位置是：<a href=\"https://github.com/infobloxopen/cni-infoblox\">infobloxopen&#x2F;cni-infoblox: CNI Infoblox Code (github.com)</a></p>\n<p>相关文档是：<a href=\"https://blogs.infoblox.com/community/cni-networking-and-ipam/\">CNI Networking and IPAM (infoblox.com)</a></p>\n<h3 id=\"Multus-a-Multi-plugin\"><a href=\"#Multus-a-Multi-plugin\" class=\"headerlink\" title=\"Multus - a Multi plugin\"></a><a href=\"https://github.com/k8snetworkplumbingwg/multus-cni\">Multus - a Multi plugin</a></h3><p>仓库位置是：<a href=\"https://github.com/k8snetworkplumbingwg/multus-cni\">k8snetworkplumbingwg&#x2F;multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md\">multus-cni&#x2F;how-to-use.md at master · k8snetworkplumbingwg&#x2F;multus-cni (github.com)</a></p>\n<h3 id=\"Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes\"><a href=\"#Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes\" class=\"headerlink\" title=\"Romana - Layer 3 CNI plugin supporting network policy for Kubernetes\"></a><a href=\"https://github.com/romana/kube\">Romana - Layer 3 CNI plugin supporting network policy for Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/romana/kube\">romana&#x2F;kube: Kubernetes specific components for Romana (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/romana/romana\">romana&#x2F;romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)</a></p>\n<h3 id=\"CNI-Genie-generic-CNI-network-plugin\"><a href=\"#CNI-Genie-generic-CNI-network-plugin\" class=\"headerlink\" title=\"CNI-Genie - generic CNI network plugin\"></a><a href=\"https://github.com/Huawei-PaaS/CNI-Genie\">CNI-Genie - generic CNI network plugin</a></h3><p>仓库位置是：<a href=\"https://github.com/huawei-cloudnative/CNI-Genie\">huawei-cloudnative&#x2F;CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support\"><a href=\"#Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support\" class=\"headerlink\" title=\"Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support\"></a><a href=\"https://github.com/nuagenetworks/nuage-cni\">Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support</a></h3><p>仓库位置是：<a href=\"https://github.com/nuagenetworks/nuage-cni\">nuagenetworks&#x2F;nuage-cni: Nuage VSP plugin for the CNI project (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Silk-a-CNI-plugin-designed-for-Cloud-Foundry\"><a href=\"#Silk-a-CNI-plugin-designed-for-Cloud-Foundry\" class=\"headerlink\" title=\"Silk - a CNI plugin designed for Cloud Foundry\"></a><a href=\"https://github.com/cloudfoundry-incubator/silk\">Silk - a CNI plugin designed for Cloud Foundry</a></h3><p>仓库位置是：<a href=\"https://github.com/cloudfoundry/silk\">cloudfoundry&#x2F;silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment\"><a href=\"#Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment\" class=\"headerlink\" title=\"Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN&#x2F;OpenFlow network environment\"></a><a href=\"https://github.com/John-Lin/linen-cni\">Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN&#x2F;OpenFlow network environment</a></h3><p>仓库位置是：<a href=\"https://github.com/John-Lin/linen-cni\">John-Lin&#x2F;linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-VPP\"><a href=\"#Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-VPP\" class=\"headerlink\" title=\"Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP\"></a><a href=\"https://github.com/intel/vhost-user-net-plugin\">Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP</a></h3><p>仓库位置是：<a href=\"https://github.com/intel/userspace-cni-network-plugin\">intel&#x2F;userspace-cni-network-plugin (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami\">Userspace CNI Design document - Google 文档</a></p>\n<h3 id=\"Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs\"><a href=\"#Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs\" class=\"headerlink\" title=\"Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)\"></a><a href=\"https://github.com/aws/amazon-ecs-cni-plugins\">Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)</a></h3><p>仓库位置是：<a href=\"https://github.com/aws/amazon-ecs-cni-plugins\">aws&#x2F;amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html\">What is Amazon Elastic Container Service? - Amazon Elastic Container Service</a></p>\n<h3 id=\"Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network\"><a href=\"#Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network\" class=\"headerlink\" title=\"Bonding CNI - a Link aggregating plugin to address failover and high availability network\"></a><a href=\"https://github.com/Intel-Corp/bond-cni\">Bonding CNI - a Link aggregating plugin to address failover and high availability network</a></h3><p>仓库位置是：<a href=\"https://github.com/k8snetworkplumbingwg/bond-cni\">k8snetworkplumbingwg&#x2F;bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows\"><a href=\"#ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows\" class=\"headerlink\" title=\"ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows\"></a><a href=\"https://github.com/openvswitch/ovn-kubernetes\">ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows</a></h3><p>仓库位置是：<a href=\"https://github.com/ovn-org/ovn-kubernetes\">ovn-org&#x2F;ovn-kubernetes: Kubernetes integration for OVN (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.openvswitch.org/en/latest/intro/install/\">Installing Open vSwitch — Open vSwitch 3.1.90 documentation</a></p>\n<h3 id=\"Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing\"><a href=\"#Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing\" class=\"headerlink\" title=\"Juniper Contrail &#x2F; TungstenFabric - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing\"></a><a href=\"https://www.juniper.net/cloud\">Juniper Contrail</a> &#x2F; <a href=\"https://tungstenfabric.io/\">TungstenFabric</a> - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing</h3><p>仓库位置是：<a href=\"https://www.juniper.net/us/en/it-networking.html\">Enterprise IT Networking Products &amp; Solutions | Juniper Networks US</a></p>\n<p>相关文档是：<a href=\"https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx\">Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.</a></p>\n<blockquote>\n<p>无法参考，为保证资料完整性留存</p>\n</blockquote>\n<h3 id=\"Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes\"><a href=\"#Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes\" class=\"headerlink\" title=\"Knitter - a CNI plugin supporting multiple networking for Kubernetes\"></a><a href=\"https://github.com/ZTE/Knitter\">Knitter - a CNI plugin supporting multiple networking for Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/ZTE/Knitter\">ZTE&#x2F;Knitter: Kubernetes network solution (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/ZTE/Knitter/tree/master/docs\">Knitter&#x2F;docs at master · ZTE&#x2F;Knitter (github.com)</a></p>\n<h3 id=\"DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes\"><a href=\"#DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes\" class=\"headerlink\" title=\"DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes\"></a><a href=\"https://github.com/nokia/danm\">DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/nokia/danm\">nokia&#x2F;danm: TelCo grade network management in a Kubernetes cluster (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/nokia/danm/blob/master/deployment-guide.md\">danm&#x2F;deployment-guide.md at master · nokia&#x2F;danm (github.com)</a></p>\n<h3 id=\"VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster\"><a href=\"#VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster\" class=\"headerlink\" title=\"VMware NSX – a CNI plugin that enables automated NSX L2&#x2F;L3 networking and L4&#x2F;L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.\"></a><a href=\"https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html\">VMware NSX – a CNI plugin that enables automated NSX L2&#x2F;L3 networking and L4&#x2F;L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.</a></h3><p>仓库位置是：<a href=\"https://github.com/weaveworks/weave/tree/master/plugin\">weave&#x2F;plugin at master · weaveworks&#x2F;weave (github.com)</a></p>\n<p>相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]</p>\n<h3 id=\"cni-route-override-a-meta-CNI-plugin-that-override-route-information\"><a href=\"#cni-route-override-a-meta-CNI-plugin-that-override-route-information\" class=\"headerlink\" title=\"cni-route-override - a meta CNI plugin that override route information\"></a><a href=\"https://github.com/redhat-nfvpe/cni-route-override\">cni-route-override - a meta CNI plugin that override route information</a></h3><p>仓库位置是：<a href=\"https://github.com/redhat-nfvpe/cni-route-override\">redhat-nfvpe&#x2F;cni-route-override: CNI plugin to override routes for a container interface (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product\"><a href=\"#Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product\" class=\"headerlink\" title=\"Terway - a collection of CNI Plugins based on alibaba cloud VPC&#x2F;ECS network product\"></a><a href=\"https://github.com/AliyunContainerService/terway\">Terway - a collection of CNI Plugins based on alibaba cloud VPC&#x2F;ECS network product</a></h3><p>仓库位置是：<a href=\"https://github.com/AliyunContainerService/terway\">AliyunContainerService&#x2F;terway: CNI plugin for Alibaba Cloud VPC&#x2F;ENI (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model\"><a href=\"#Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model\" class=\"headerlink\" title=\"Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.\"></a><a href=\"https://github.com/noironetworks/aci-containers\">Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.</a></h3><p>仓库位置是：<a href=\"https://github.com/noironetworks/aci-containers\">noironetworks&#x2F;aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc\"><a href=\"#Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc\" class=\"headerlink\" title=\"Kube-OVN - a CNI plugin that bases on OVN&#x2F;OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.\"></a><a href=\"https://github.com/kubeovn/kube-ovn\">Kube-OVN - a CNI plugin that bases on OVN&#x2F;OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.</a></h3><p>仓库位置是：<a href=\"https://github.com/kubeovn/kube-ovn\">kubeovn&#x2F;kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md\">kube-ovn&#x2F;install.md at master · kubeovn&#x2F;kube-ovn (github.com)</a></p>\n<h3 id=\"Project-Antrea-an-Open-vSwitch-k8s-CNI\"><a href=\"#Project-Antrea-an-Open-vSwitch-k8s-CNI\" class=\"headerlink\" title=\"Project Antrea - an Open vSwitch k8s CNI\"></a><a href=\"https://github.com/vmware-tanzu/antrea\">Project Antrea - an Open vSwitch k8s CNI</a></h3><p>仓库位置是：<a href=\"https://github.com/antrea-io/antrea\">antrea-io&#x2F;antrea: Kubernetes networking based on Open vSwitch (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md\">antrea&#x2F;getting-started.md at main · antrea-io&#x2F;antrea (github.com)</a></p>\n<h3 id=\"OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking\"><a href=\"#OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking\" class=\"headerlink\" title=\"OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking\"></a><a href=\"https://github.com/opnfv/ovn4nfv-k8s-plugin\">OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking</a></h3><p>仓库位置是：<a href=\"https://github.com/opnfv/ovn4nfv-k8s-plugin\">opnfv&#x2F;ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.</a></p>\n<p>相关文档是：同一位置</p>\n<blockquote>\n<p>已经关闭</p>\n</blockquote>\n<h3 id=\"Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers\"><a href=\"#Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers\" class=\"headerlink\" title=\"Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers\"></a><a href=\"https://github.com/Azure/azure-container-networking\">Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers</a></h3><p>仓库位置是：<a href=\"https://github.com/Azure/azure-container-networking\">Azure&#x2F;azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/Azure/azure-container-networking/tree/master/docs\">azure-container-networking&#x2F;docs at master · Azure&#x2F;azure-container-networking (github.com)</a></p>\n<h3 id=\"Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity\"><a href=\"#Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity\" class=\"headerlink\" title=\"Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.\"></a><a href=\"https://github.com/alibaba/hybridnet\">Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.</a></h3><p>仓库位置是：<a href=\"https://github.com/alibaba/hybridnet\">alibaba&#x2F;hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/alibaba/hybridnet/wiki\">Home · alibaba&#x2F;hybridnet Wiki (github.com)</a></p>\n<h3 id=\"Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network\"><a href=\"#Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network\" class=\"headerlink\" title=\"Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network\"></a><a href=\"https://github.com/spidernet-io/spiderpool\">Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network</a></h3><p>仓库位置是：<a href=\"https://github.com/spidernet-io/spiderpool\">spidernet-io&#x2F;spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md\">spiderpool&#x2F;install.md at main · spidernet-io&#x2F;spiderpool (github.com)</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cluv14vf7000052pe1ogs48zx","category_id":"cluv14vfd000252pe5tdf0lo3","_id":"cluv14vfg000852peb8gphauz"},{"post_id":"cluv14vff000452pegtp99u7a","category_id":"cluvbsnor000182pe3uz83kj9","_id":"cluvbsnp0000782pegt8acccx"},{"post_id":"cluv14vfc000152peb33e2u5g","category_id":"cluvbsnor000182pe3uz83kj9","_id":"cluvbsnp1000a82pe8eeo1nti"},{"post_id":"cluvbsnop000082peatwdaki3","category_id":"cluvbsnor000182pe3uz83kj9","_id":"cluvbsnp1000d82pe5dni0ayw"},{"post_id":"cluvbsnov000382pe9v07ecmy","category_id":"cluvbsnor000182pe3uz83kj9","_id":"cluvbsnp2000g82peaxysb258"},{"post_id":"cluv14vfi000b52pedgek3jlr","category_id":"cluvbsnp1000c82pee1433tmd","_id":"cluvbsnp2000j82pe9bv40h3r"}],"PostTag":[{"post_id":"cluv14vf7000052pe1ogs48zx","tag_id":"cluv14vfe000352pe82er6v6b","_id":"cluv14vfg000752pe2l2e2s7g"},{"post_id":"cluvbsnop000082peatwdaki3","tag_id":"cluvbsnoy000582pe7iafckdn","_id":"cluvbsnp1000b82pe01wx0y82"},{"post_id":"cluvbsnov000382pe9v07ecmy","tag_id":"cluvbsnoy000582pe7iafckdn","_id":"cluvbsnp2000f82pegc1j3ufn"},{"post_id":"cluv14vff000452pegtp99u7a","tag_id":"cluvbsnoy000582pe7iafckdn","_id":"cluvbsnp2000i82pebrtkh7sr"},{"post_id":"cluv14vfi000b52pedgek3jlr","tag_id":"cluvbsnp2000h82pe5br14dlr","_id":"cluvbsnp2000k82pe9a44gdx7"},{"post_id":"cluv14vfc000152peb33e2u5g","tag_id":"cluvbsnoy000582pe7iafckdn","_id":"cluvbtmsa00008qped9n2f7iy"}],"Tag":[{"name":"AI, overview","_id":"cluv14vfe000352pe82er6v6b"},{"name":"ospp, CNI, Linux,","_id":"cluv14vfg000652pegszdcpz8"},{"name":"ospp, cni, Linux,","_id":"cluvbsnou000282pe0iqxcj9q"},{"name":"ospp, cni, Linux","_id":"cluvbsnoy000582pe7iafckdn"},{"name":"Hexo, Blog, docker","_id":"cluvbsnp2000h82pe5br14dlr"}]}}